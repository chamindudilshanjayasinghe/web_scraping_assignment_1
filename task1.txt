Link text: DSA Tutorial - Learn Data Structures and Algorithms - GeeksforGeeks
URL: https://www.geeksforgeeks.org/dsa-tutorial-learn-data-structures-and-algorithms/
Article headline: DSA Tutorial - Learn Data Structures and Algorithms
Last updated: 25 Sep, 2025
Description: DSA stands for D ata S tructures and A lgorithms. Data structures manage how data is stored and accessed. Algorithms focus on processing this data.  Examples of data structures are Array, Linked List, Tree and Heap, and examples of algorithms are Binary Search, Quick Sort and Merge Sort. Try our free courses GfG 160 and DSA Skillup with daily topic coverage, notes, quizzes and most asked coding problems. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory , allowing for constant-time access . Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order , such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. I n Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. I n Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. I n Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. A sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). A programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. A two-dimensional array of elements, arranged in rows and columns . It is represented as a rectangular grid, with each element at the intersection of a row and column. A linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially , starting from the head of list. A linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A Deque or double-ended queue is a data structure that allows elements to be added or removed from both ends efficiently. A non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems , databases , decision-making algorithms , etc. A complete binary tree that satisfies the heap property . Heaps are usually used to implement priority queues , where the smallest or largest element is always at the root of the tree. A non-linear data structure consisting of a finite set of vertices (or nodes) and a set of edges (or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems . By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Advanced Data Structures like Trie , Segment Tree , Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer: A strategy to solve problems by dividing them into smaller subproblems , solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable.
======================================================================

Link text: Java Tutorial - Learn Java Programming
URL: https://www.geeksforgeeks.org/java/
Article headline: Java Tutorial
Last updated: 04 Oct, 2025
Description: Java is a high-level, object-oriented programming language used to build web apps, mobile applications, and enterprise software systems. Try our ongoing free courses Java Skillup and Advance Java Skillup with weekly topic coverage, notes, daily quizzes and coding problems. Here is a simple Java program that prints "Hello World". Java basics form the foundation of your programming journey, covering essential concepts like syntax, data types, variables, loops, and conditionals. Java methods are reusable blocks of code that perform specific tasks and help organize your program. They improve code readability, reduce repetition, and make debugging easier. Java arrays are containers that store multiple values of the same data type in a single variable. They provide an efficient way to manage and access collections of data using index-based positions. Java Strings represent sequences of characters and are widely used in text processing. They are immutable, meaning once created, their values cannot be changed. Java Regex (Regular Expressions) allows pattern matching and text manipulation using the java.util.regex package. It is powerful for validating, searching, and replacing strings based on specific patterns. Java follows the Object-Oriented Programming (OOP) paradigm, which organizes code into classes and objects. Core OOP principles like inheritance, encapsulation, polymorphism, and abstraction make Java modular and scalable. Java interfaces define a contract that classes must follow, specifying method signatures without implementations. They enable abstraction and support multiple inheritance in Java through a clean, structured approach. ava Exception Handling is a mechanism to handle runtime errors, ensuring the program runs smoothly without crashing. It uses keywords like try, catch, throw, throws, and finally to manage exceptions. Java Memory Allocation refers to how memory is assigned to variables, objects, and classes during program execution. It involves stack and heap memory, with the JVM managing allocation and garbage collection automatically. Java Collections provide a framework for storing and manipulating groups of objects efficiently. It includes interfaces like List, Set, and Map, along with classes like ArrayList, HashSet, and HashMap. Java Streams and Lambda Expressions simplify data processing by enabling functional-style operations on collections. Lambdas provide concise syntax for anonymous functions, while Streams allow efficient filtering, mapping, and reduction of data. Java Multithreading allows concurrent execution of two or more threads, enabling efficient CPU utilization and faster program performance. It is commonly used for tasks that required parallel processing and responsiveness from multiple ends. Java File Handling enables programs to create, read, write, and manipulate files stored on the system. It uses classes from the java.io and java.nio packages for efficient file operations. Java Networking enables communication between devices over a network using classes from the java.net package. It supports protocols like TCP and UDP for building client-server applications and data exchange. Prepare for Java interviews with these commonly asked questions, covering core concepts, OOP, collections, multithreading, exception handling, and frameworks like Spring and Hibernate.
======================================================================

Link text: Python Tutorial | Learn Python Programming Language
URL: https://www.geeksforgeeks.org/python-programming-language-tutorial/
Article headline: Python Tutorial - Learn Python Programming Language
Last updated: 02 Oct, 2025
Description: Python is one of the most popular programming languages. It’s simple to use, packed with features and supported by a wide range of libraries and frameworks. Its clean syntax makes it beginner-friendly. Try our ongoing free course Python Skillup with weekly topic coverage, notes, daily quizzes and coding problems. Here is a simple Python code, printing a string. We recommend you to edit the code and try to print your own name. In this section, we’ll cover the basics of Python programming, including installing Python, writing first program, understanding comments and working with variables, keywords and operators. Before starting to learn python we need to install python on our system. In this section of Python 3 tutorial we'll explore Python function syntax, parameter handling, return values and variable scope. Along the way, we'll also introduce versatile functions like range(), map, filter and lambda functions. Python offers versatile collections of data types, including lists, string, tuples, sets, dictionaries and arrays. In this section, we will learn about each data types in detail. Python's collections module offers essential data structures, including the following: To learn data structure and algorithm with python in detail, you can refer to our DSA with Python Tutorial. In this section, we'll explore the core principles of object-oriented programming (OOP) in Python. From encapsulation to inheritance, polymorphism, abstract classes and iterators, we'll cover the essential concepts that helps you to build modular, reusable and scalable code. In this section, we'll explore Python Exception Handling that how Python deals with unexpected errors, enabling us to write fault-tolerant code. We'll cover file handling, including reading from and writing to files. In this section, we will cover file handling, including reading from and writing to files. In this section we will learn how to access and work with MySQL and MongoDB databases Python is a huge collection of Python Packages standard libraries that make development easier. These libraries help with a wide range of tasks and can save you a lot of time by providing ready-to-use tools. Some commonly used types of libraries in Python include: 1. Foundational Libraries : These are the libraries that form the base for all data science work. Start here to build a strong foundation. 2. Advanced Visualization and Statistical Tools: Once you’re comfortable with basic data handling and visualization, move to creating cleaner visuals and performing statistical analysis. 3. Machine Learning Libraries: After data manipulation and visualization, learn machine learning, starting with simpler models and moving to advanced ones. 4. Deep Learning Frameworks: If you’re interested in AI and deep learning, these libraries will allow you to build and train neural networks. To learn more, you can refer to Python for Data Science . 1. Core Web Frameworks (Backend Development with Python): These are the tools for building Python-based web applications. 2. Database Integration: Learn how to connect Python web frameworks to databases for storing and retrieving data. 3. Front-End and Backend Integration: Learn how to connect Python backends with front-end technologies to create dynamic, full-stack web applications. 4. API Development: Learn to build APIs (Application Programming Interfaces) for connecting your backend with front-end apps or other services. To learn more, you can refer to Python for Web Development. Python quiz page covers topics including variables, data types, input, output, lists, tuples, dictionaries and sets. The Python Coding Practice Problems page offers exercises on loops, functions, lists, strings, dictionaries, sets and advanced structures like heaps and deques. This Python tutorial is updated based on latest Python 3.13.1 version.
======================================================================

Link text: Web Technology
URL: https://www.geeksforgeeks.org/web-technology/
Article headline: Web Development Technologies
Last updated: 10 Sep, 2025
Description: Web development refers to building, creating, and maintaining websites. It includes aspects such as web design, web publishing, web programming, and database management. It is the creation of an application that works over the internet, i.e., websites. To better understand the foundation of web development, it is recommended to take a look at the concepts used in web development. Do you wish to learn Web Development in a scheduled manner ? Try our ongoing free course Web Development Skillup with weekly topic coverage, notes, quizzes and practical projects. There are two major areas: Frontend and Backend which forms the backbone of web development each plays a crucial role in creating seamless, functional web experiences. In this module, we explore the core technologies that run in the user’s browser—the client side—including how web pages are structured, styled, and made interactive, building everything users see and interact with. In this module, we will explore the technologies that work behind the scenes on the server to handle data, run the website, and store information .  In Backend Development, Server-side programming languages are used to write code that runs on the server, not in the user’s browser. This server-side scripting handles tasks like processing data, managing databases, and controlling how the website works behind the scenes Below are some popular languages used to build the back end of web applications: A database is where a website’s data like user's data, product's data are stored and organized. It is part of the backend (server side) that manages and keeps this information safe. Websites use databases to save and access information like user details, content, and transactions. Some databases organize data in tables (called relational databases, like MySQL), while others store data in flexible formats (called NoSQL databases, like MongoDB). There are basically two types of databases: 1. SQL/Relational Database A relational database stores data in tables, similar to a spreadsheet, where each table has rows and columns. The rows hold individual records, and the columns define the data attributes. Tables can be linked to each other through special keys, allowing related data to be connected. 2. NoSQL Databases A NoSQL database stores data in a flexible, non-tabular format, unlike traditional relational databases. Instead of using tables with rows and columns, NoSQL databases might use documents, key-value pairs, wide-columns, or graphs to store data. This allows them to handle large amounts of unstructured or semi-structured data efficiently. They are designed to scale easily and manage big data applications. Note: We use Database management systems help keep the data safe, organized, and easy to use. During Website development, different software components and web applications constantly need to communicate and share information. For instance, the frontend of your web application (running in the user's browser) needs to get data from the backend (running on a server), or your application might need to fetch information from a third-party service like a weather provider or a payment gateway. This communication is made possible through Application Programming Interfaces (APIs) and standardized Data Formats. Data Exchange formate for API Communication: When applications communicate via APIs, they need a common, structured way to represent the data being exchanged. This is where data formats come in. Below are two common data formats used extensively in web development for API communication: Developing a web application involves more than just writing code. Two critical processes that ensure a smooth, organized, and reliable development workflow are Version Control and Deployment . Version control helps manage the evolution of your codebase, especially when working in teams, while deployment is the process of making your web application accessible to the world. Modern development practices tightly integrate these two concepts, often through automation. Graphical elements are one of the key feature of any webpage. They can be used to convey important points better than text does and beautify the webpage.
======================================================================

Link text: 7 Different Ways to Take a Screenshot in Windows 10 - GeeksforGeeks
URL: https://www.geeksforgeeks.org/how-to-take-screenshots-in-windows-10/
Article headline: 7 Different Ways to Take a Screenshot in Windows 10
Last updated: 23 Jul, 2025
Description: Taking Screenshots has become one of the necessary components of our daily life. Whatever device, we are using, we face the need to take screenshots there. Also no doubt, the Screenshots help to describe any action more clearly than any other means. Keep in mind that, Windows comes up with different Methods to Take Windows Screenshots . In earlier times, there was only one way to Capture Screenshots on Windows . That is the using Windows Keyboard Shortcuts . But as the demand is increasing, there are more new ways introduced to Grab Screenshot on Windows 10 . We can enlist 7 different methods to Get the Windows Screenshot . This article is going to be a detailed guideline about the Ways to Take Screenshots in the Windows 10 operating system. To Take Screenshots of the Windows Screen , the following methods can be used. In this guideline, we will start with the PRT SC Key execution. Step 1: When you have decided what you want to capture as a screenshot, tap on the PrtSc key on your keyboard immediately. Step 2: The previous step will automatically get a screenshot of the screen and store it in the clipboard of your Windows PC. Since it will not save directly as an image, you can open another editor app, like Paint . Step 3: On the clear white canvas of the Paint app, put the cursor on the page and press Ctrl + V keys . This will drop the image from the clipboard onto the page. Step 4: Click on File > Save As . Name the screenshot and choose the location to save it in. Then, press the Save button . Step 1: When you have many windows open on your device, press the Alt + Win + PrtSc keys together . Step 2: The screenshot will be stored immediately in the folder named Videos > Captures once you press the Alt + Win + PrtSc keys . If you want to take a quick and accurate screenshot on your screen and avoid saving it into the clipboard, you can press the Windows and PrtScn keys together . This will bring up the thumbnail on the screen at the bottom-left side when the screenshot capture step is done. You will find the screenshot in your device's Pictures/Screenshots folder , accessible through the File Manager . Step 1: When you need to screenshot something on the screen, tap on the Windows button (⊞ ) from the taskbar below. Step 2: Type in the Snipping tool in the search field. Click on the first app option that comes in the result to open it. Step 3: You will see multiple options in the app when it opens on your Windows 10 PC. These include: Step 4: After setting up the features for the Snipping Tool to take the screenshot, press the New Option . The screen will appear with a white overlay showcasing the uncaptured area. Step 5: The screenshot will appear in the Spinning Tool after you capture one. Step 6: Tap on the File tab and choose the "Save As" option to move the screenshot to your preferred location on the hard drive. The app does not automatically save the screenshots anywhere. Step 1: Go to the window or page you will capture. Press Win + Shift + S keyboard shortcut or click the Start menu from the taskbar > type Snip & Sketch > tap the option. Step 2: After the tool opens, you will see many options as icons, like: Step 3: After capturing the screenshot, the image will be saved in the clipboard . Click on it from the notification that pops up on your screen. Tap on it for markup/file sharing. Step 4: If the popup notification does not appear, go to the Notifications bar at the right part of the screen to access the Snip & Sketch tool. Step 5: Save the file in the Paint app to cut the screen size. Then save the file. Step 1: For this app to work for screenshotting, you have to activate the Game Bar feature on your PC first.  For that, go to Settings > Gaming . Then, activate the slider for the Game Bar operation in the next window. Step 2: On your PC, tap the Win + G keys to access the Game Bar. Step 3: Then tap on the Capture option. Or, press Win + Alt + PrtSc . Step 4: The full-screen screenshot of the window you capture automatically saves into Videos > Captures . Click on it from File Manager to find and use it later. Step 1: Go to the desired screen of which you're looking to take the screenshot and hit Alt + Prt Sc (Print screen) at the same time. Step 2: You will be required to select the desired area in which you want to take the screenshot, click, the and save it as required. Step 3: An image will be copied and can be pasted simply on the Paint app. Taking a Screenshot on PC isn't a tough task, even if you aren't a tech-savvy person. All you need to do is follow this step-by-step Guide to Take Screenshots of anything on your PC. Use the simple PrtSc key for this process or different tools available on the device. Follow the steps correctly to avoid errors with this function on a Windows PC.
======================================================================

Link text: Enumerate() in Python - GeeksforGeeks
URL: https://www.geeksforgeeks.org/enumerate-in-python/
Article headline: Enumerate() in Python
Last updated: 12 Sep, 2025
Description: enumerate() function adds a counter to each item in a list or any other iterable, and returns a list of tuples containing the index position and the element for each element of the iterable. It turns the iterable into something we can loop through using indexes, where each item comes with its number (starting from 0 by default). Let's look at a simple example of an enumerate() with a list. Explanation: enumerate(a) provides both the index (i) and the element (name) during iteration. enumerate(iterable, start=0) By default enumrate() starts from index 0. We can customize this using the start parameter. if want the index to begin at value other than 0. In Python, the enumerate() function serves as an iterator, inheriting all associated iterator functions and methods. Therefore, we can use the next() function and __next__() method with an  enumerate object. Each time the next() is called, the internal pointer of the enumerate object moves to the next element, returning the corresponding tuple of index and value. We can use enumerate() with a dictionary to get both the index and its key-value pair: Related Articles:
======================================================================

Link text: Insertion Sort Algorithm - GeeksforGeeks
URL: https://www.geeksforgeeks.org/insertion-sort-algorithm/
Article headline: Insertion Sort Algorithm
Last updated: 23 Jul, 2025
Description: Insertion sort is a simple sorting algorithm that works by iteratively inserting each element of an unsorted list into its correct position in a sorted portion of the list. It is like sorting playing cards in your hands. You split the cards into two groups: the sorted cards and the unsorted cards. Then, you pick a card from the unsorted group and put it in the right place in the sorted group.  arr = {23, 1, 10, 5, 2} Initial: First Pass: Second Pass: Third Pass: Fourth Pass: Final Array: Time Complexity Space Complexity Please refer Complexity Analysis of Insertion Sort for details. Advantages Disadvantages Insertion sort is commonly used in situations where: What are the Boundary Cases of the Insertion Sort algorithm? Insertion sort takes the maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. What is the Algorithmic Paradigm of the Insertion Sort algorithm? The Insertion Sort algorithm follows an incremental approach. Is Insertion Sort an in-place sorting algorithm? Yes, insertion sort is an in-place sorting algorithm. Is Insertion Sort a stable algorithm? Yes, insertion sort is a stable sorting algorithm. When is the Insertion Sort algorithm used? Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, and only a few elements are misplaced in a complete big array.
======================================================================

Link text: Full Stop Punctuation - Meaning, Usage and Examples
URL: https://www.geeksforgeeks.org/full-stop-punctuation/
Article headline: Full Stop Punctuation
Last updated: 13 Jun, 2025
Description: A full stop (or period) is a dot-like symbol (.) you put at the end of a sentence. It's mostly used when you've finished a regular statement or a command. This dot tells you to pause longer than you would for a comma or a semicolon. It also shows you've finished one idea and are moving to another. Different dictionaries explain a full stop similarly. The Oxford Learner's Dictionary says it's used at the end of a sentence to show there's nothing more to say about the topic. Merriam-Webster calls it a point used to mark the end of a sentence or an abbreviation. The Cambridge Dictionary describes it as a symbol used at the end of a sentence or a shortened word. And the Collins Dictionary explains it as the punctuation mark at the end of a sentence that is not a question or exclamation. Using a full stop, or a period, is straightforward, but there are some important rules to remember: Remember, full stops are crucial for clear and effective written communication, helping to convey the right pace and tone. Here are some examples to illustrate how to use a full stop: These examples show how full stops are used in different contexts to clearly mark the end of sentences or to punctuate abbreviations. Remember, the full stop is one of the simplest yet most powerful tools in punctuation.  
======================================================================

Link text: f-strings in Python - GeeksforGeeks
URL: https://www.geeksforgeeks.org/formatted-string-literals-f-strings-python/
Article headline: f-strings in Python
Last updated: 25 Sep, 2025
Description: Python introduced f-strings (formatted string literals) in version 3.6 to make string formatting and interpolation easier. With f-strings, you can directly embed variables and expressions inside strings using curly braces {}. How to use f-strings? Simply prefix a string with f and place variables or expressions inside {}. This works like str.format(), but in a more concise and readable way. Formatting codes: Note: F-strings are faster than the two most commonly used string formatting mechanisms, which are % formatting and str.format(). In Python f-string, Backslash Cannot be used in format string directly. Output However, we can put the backslash into a variable as a workaround though : We cannot use comments inside F-string expressions. It will give an error: Output:
======================================================================

Link text: What is OSI Model | 7 Layers Explained
URL: https://www.geeksforgeeks.org/open-systems-interconnection-model-osi/
Article headline: What is OSI Model? - Layers of OSI Model
Last updated: 19 Sep, 2025
Description: The OSI (Open Systems Interconnection) Model is a set of rules that explains how different computer systems communicate over a network. OSI Model was developed by the International Organization for Standardization (ISO). The OSI Model consists of 7 layers and each layer has specific functions and responsibilities. This layered approach makes it easier for different devices and technologies to work together. Note: OSI Model provides a clear structure for data transmission and managing network issues. The OSI Model is widely used as a reference to understand how network systems function. There are 7 layers in the OSI Model and each layer has its specific role in handling data. All the layers are mentioned below: The lowest layer of the OSI reference model is the Physical Layer. It is responsible for the actual physical connection between the devices. The physical layer contains information in the form of bits. The data link layer is responsible for the node-to-node delivery of the message. The main function of this layer is to make sure data transfer is error-free from one node to another, over the physical layer. The network layer works for the transmission of data from one host to the other located in different networks. It also takes care of packet routing i.e. selection of the shortest path to transmit the packet, from the number of routes available. The transport layer provides services to the application layer and takes services from the network layer. The data in the transport layer is referred to as Segments. It is responsible for the end-to-end delivery of the complete message. Session Layer in the OSI Model is responsible for the establishment of connections, management of connections, terminations of sessions between two devices. It also provides authentication and security. Protocols used in the Session Layer are NetBIOS, PPTP. Example Let us consider a scenario where a user wants to send a message through some Messenger application running in their browser. The “Messenger” here acts as the application layer which provides the user with an interface to create the data. This message or so-called Data  is compressed, optionally encrypted (if the data is sensitive), and converted into bits (0’s and 1’s) so that it can be transmitted. The presentation layer is also called the Translation layer. The data from the application layer is extracted here and manipulated as per the required format to transmit over the network. Protocols used in the Presentation Layer are TLS/SSL (Transport Layer Security / Secure Sockets Layer). JPEG, MPEG, GIF , are standards or formats used for encoding data, which is part of the presentation layer’s role. At the very top of the OSI Reference Model stack of layers, we find the Application layer which is implemented by the network applications. These applications produce the data to be transferred over the network. The main functions of the application layer are given below. When we transfer information from one device to another, it travels through 7 layers of OSI model. First data travels down through 7 layers from the sender's end and then climbs back 7 layers on the receiver's end. Data flows through the OSI model in a step-by-step process: Each layer adds specific information to ensure the data reaches its destination correctly, and these steps are reversed upon arrival. We can understand how data flows through OSI Model with the help of an example mentioned below. Let us suppose, Person A sends an e-mail to his friend Person B. After the email reaches the receiver i.e. Person B, the process will reverse and decrypt the e-mail content. At last, the email will be shown on Person B email client. Layer Working Protocol Data Unit Protocols 1: Physical Layer Establishing Physical Connections between Devices. Bits USB , SONET/SDH , etc. 2: Data Link Layer Node to Node Delivery of Message. Frames Ethernet , PPP, etc. 3: Network Layer Transmission of data from one host to another, located in different networks. Packets IP, ICMP , IGMP , OSPF , etc. 4: Transport Layer Take Service from Network Layer and provide it to the Application Layer. Segments (for TCP) or Datagrams (for UDP) TCP , UDP , SCTP, etc. 5: Session Layer Establishes Connection, Maintenance, Ensures Authentication and Ensures security. Data NetBIOS , RPC , PPTP , etc. 6: Presentation Layer Data from the application layer is extracted and manipulated in the required format for transmission. Data TLS/SSL , MIME , etc. 7: Application Layer Helps in identifying the client and synchronizing communication. Data FTP , SMTP , DNS , DHCP , etc. The OSI Model matters because it provides the user a clear structure of "how the data moves in the network?". As the OSI Model consists of 7 layers, each layer has its specific role, and due to which it helps in understanding, identifying and solving the complex network problems easily by focusing on one of the layers not the entire network. Note: As the modern Internet does not prefer the OSI Model, but still, the OSI Model is still very helpful for solving network problems. It helps people understanding network concepts very easily.
======================================================================

Link text: Merge Sort - Data Structure and Algorithms Tutorials - GeeksforGeeks
URL: https://www.geeksforgeeks.org/merge-sort/
Article headline: Merge Sort
Last updated: 03 Oct, 2025
Description: Merge sort is a popular sorting algorithm known for its efficiency and stability. It follows the  Divide and Conquer approach.  It works by recursively dividing the input array into two halves,  recursively sorting the two halves and finally merging them back  together to obtain the sorted array. Here's a step-by-step explanation of how merge sort works: Let's sort the array or list [38, 27, 43, 10] using Merge Sort Let's look at the working of above example: Divide: Conquer: Merge: Therefore, the sorted list is [10, 27, 38, 43] . The recurrence relation of merge sort is: T(n) = \begin{cases} \Theta(1) & \text{if } n = 1 \\ 2T\left(\frac{n}{2}\right) + \Theta(n) & \text{if } n > 1 \end{cases} Time Complexity: Auxiliary Space: O(n), Additional space is required for the temporary array used during merging. Advantages Disadvantages Quick Links:
======================================================================

Link text: Binary Search Algorithm - Iterative and Recursive Implementation - GeeksforGeeks
URL: https://www.geeksforgeeks.org/binary-search/
Article headline: Binary Search
Last updated: 10 Sep, 2025
Description: Binary Search is a searching algorithm that operates on a sorted or monotonic search space, repeatedly dividing it into halves to find a target value or optimal answer in logarithmic time O(log N). To apply Binary Search algorithm: Below is the step-by-step algorithm for Binary Search: To understand the working of binary search, consider the following illustration: Consider an array arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91} , and the target = 23 . The Binary Search Algorithm can be implemented in the following two ways Here we use a while loop to continue the process of comparing the key and splitting the search space in two halves. Create a recursive function and compare the mid of the search space with the key. And based on the result either return the index where the key is found or call the recursive function for the next search space. Please refer Time and Space Complexity Analysis of Binary Search for more details.
======================================================================

Link text: Quick Sort - GeeksforGeeks
URL: https://www.geeksforgeeks.org/quick-sort-algorithm/
Article headline: Quick Sort
Last updated: 03 Oct, 2025
Description: QuickSort is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array. It works on the principle of divide and conquer , breaking down the problem into smaller sub-problems. There are mainly three steps in the algorithm: Here’s a basic overview of how the QuickSort algorithm works. There are many different choices for picking pivots. The key process in quickSort is a partition(). There are three common algorithms to partition. All these algorithms have O(n) time complexity. The logic is simple, we start from the leftmost element and keep track of the index of smaller (or equal) elements as i . While traversing, if we find a smaller element, we swap the current element with arr[i] . Otherwise, we ignore the current element. Let us understand the working of partition algorithm with the help of the following example: In the previous step, we looked at how the partitioning process rearranges the array based on the chosen pivot . Next, we apply the same method recursively to the smaller sub-arrays on the left and right of the pivot. Each time, we select new pivots and partition the arrays again. This process continues until only one element is left, which is always sorted. Once every element is in its correct position, the entire array is sorted. Below image illustrates, how the recursive method calls for the smaller sub-arrays on the left and right of the pivot : Time Complexity: Auxiliary Space: Please refer Time and Space Complexity Analysis of Quick Sort for more details. Please refer Application of Quicksort for more details.
======================================================================

Link text: ASCII Values Alphabets ( A-Z, a-z & Special Character Table ) - GeeksforGeeks
URL: https://www.geeksforgeeks.org/ascii-table/
Article headline: ASCII Values Alphabets ( A-Z, a-z & Special Character Table )
Last updated: 23 Jul, 2025
Description: ASCII (American Standard Code for Information Interchange) is a standard character encoding used in telecommunication. The ASCII pronounced 'ask-ee', is strictly a seven-bit code based on the English alphabet. ASCII codes are used to represent alphanumeric data. The code was first published as a standard in 1967. it was subsequently updated and published as ANSI X3.4-1968, then as ANSI X3.4-1977, and finally as ANSI X3.4-1986. Since it is a seven-bit code, it can at the most represent 128 characters. it currently defines 95 printable characters including 26 upper case letters (A to Z) , 26 lower case letters , 10 numerals (0 to 9) , and 33 special characters including mathematical symbols , punctuation marks , and space characters . They represent text in, telecommunications equipment, and devices. These include numbers, upper and lowercase English letters, functions, punctuation symbols, and some other symbols. In total, there are 256 ASCII characters, and can be broadly divided into three categories: ASCII stands for American Standard Code for Information Interchange, A character encoding standard that assigns unique numerical values to letters, digits, punctuation marks, and other symbols. In the physical world, you would use a pen and paper to write the message, and your friend would read the text directly. However, when it comes to digital communication, computers don't understand letters and symbols the way humans do. Instead, they process information in the form of binary code, which consists of 0s and 1s. This is where ASCII values come into play. ASCII values serve as a bridge between human-readable text and computer-readable binary code. Each character, whether it's a letter, number, or symbol, is assigned a unique ASCII value ranging from 0 to 127. For example, the ASCII value of the uppercase letter 'A' is 65, while the lowercase letter 'a' has an ASCII value of 97. Similarly, the digit '0' has an ASCII value of 48. Suppose you want to send a text message to your friend that reads, "Hello!" When you type this message on your phone or computer, each character is converted into its corresponding ASCII value. In this case, the ASCII values for "Hello!" are 72, 101, 108, 108, 111, and 33. These numerical values are then translated into binary code, which is transmitted to your friend's device. Upon receiving the message, their device converts the binary code back into ASCII values and finally displays the original text, "Hello!" The table below adheres to the Windows-1252 (CP-1252) standard, an extension of ISO 8859-1, also known as ISO Latin-1. This standard differs from IANA's ISO-8859-1 by substituting control characters with displayable characters in the range of 128 to 159. Any characters that deviate from ISO-8859-1 are highlighted in light blue. To summarize, the range of ASCII values for capital letters spans from 65 to 90, while for small letters, it extends from 97 to 122. Allocated in alphabetical sequence, the values for "A" and "Z" are 65 and 90, respectively, in uppercase. Similarly, the values for "a" and "z" in lowercase are 97 and 122, respectively.
======================================================================

Link text: Bubble Sort Algorithm - GeeksforGeeks
URL: https://www.geeksforgeeks.org/bubble-sort-algorithm/
Article headline: Bubble Sort Algorithm
Last updated: 23 Jul, 2025
Description: Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity are quite high. Below is the implementation of the bubble sort. It can be optimized by stopping the algorithm if the inner loop didn't cause any swap. Time Complexity: O(n 2 ) Auxiliary Space: O(1) Please refer Complexity Analysis of Bubble Sort for details.
======================================================================

Link text: Python map() function
URL: https://www.geeksforgeeks.org/python-map-function/
Article headline: Python map() function
Last updated: 07 Sep, 2025
Description: map() function in Python applies a given function to each element of an iterable (list, tuple, set, etc.) and returns a map object (iterator). It is a higher-order function used for uniform element-wise transformations, enabling concise and efficient code. Let's start with a simple example of using map() to convert a list of strings into a list of integers. Explanation: map() applies int() to each element in s which changes their datatype from string to int. map(function, iterable,..) Parameters: Note: You can pass multiple iterables if the function accepts multiple arguments. By default, map() function returns a map object , which is an iterator . In many cases, we will need to convert this iterator to a list to work with the results directly. Example: Let's see how to double each elements of the given list. Explanation: We can use a lambda function instead of a custom function with map() to make code shorter and easier. Let's see how to improve above code for better readability. Explanation: lambda x: x ** 2 squares each number and the results are converted into a list . We can use map() with multiple iterables if the function we are applying takes more than one argument. Example: In this example, map() takes two iterables ( a and b ) and applies lambda function to add corresponding elements from both lists. Explanation: map() takes x from a and y from b and adds them. This example shows how we can use map() to convert a list of strings to uppercase. Explanation: str.upper method is applied to each element in the list fruits using map() . The result is a list of uppercase versions of each fruit name. In this example, we use map() to extract the first character from each string in a list. Explanation: lambda s: s[0] extracts first character from each string in the list words. map() applies this lambda function to every element, resulting in a list of the first characters of each word. In this example, We can use map() to remove leading and trailing whitespaces from each string in a list. Explanation: str.strip method removes leading and trailing whitespaces from each string in list strings. map() function applies str.strip to each element and returning a list of trimmed strings. In this example, we use map() to convert a list of temperatures from Celsius to Fahrenheit. Explanation: lambda c: (c * 9/5) + 32 converts each Celsius temperature to Fahrenheit using standard formula. map() function applies this transformation to all items in the list celsius.
======================================================================

Link text: How to Download and Install the Google Play Store?
URL: https://www.geeksforgeeks.org/download-and-install-google-play-store/
Article headline: How to Download and Install the Google Play Store
Last updated: 23 Jul, 2025
Description: The Google Play Store is the heartbeat of your Android experience—home to millions of apps, games, and updates that keep your device functional, fun, and secure. But what if your phone or tablet doesn’t have it pre-installed? In this step-by-step guide, you’ll learn how to safely download and install the Google Play Store on almost any Android device. We’ll cover how to enable installations from unknown sources, download the latest APK files (and their dependencies), and troubleshoot common errors like compatibility issues or login problems. Important Notes: While most Android devices come with the Google Play Store pre-installed, there are several scenarios where manually downloading and installing it becomes essential. Here are the most common cases: The Google Play Store offers a wide range of games, movies, e-books, and audiobooks that are user-friendly. As you've seen above, It's very rare that you don't have Google Play already installed on your Android devices. Otherwise, you need to download and install it right away. Google Play Store scans over 200 billion apps every day whether you've installed it from the Play Store or any third-party source (which is less reliable), Want to know how? Check here . It prevents your device from any malicious apps before and after being published. You can download and install the Google Play Store on your device manually using these simple steps. Here's what you need to do:   Note: It is necessary to update the Google Play Store on your device. However, the autoupdate starts by itself while connecting to the network. But if somehow, it is not updating automatically, you have to update it manually. Open the Google Play Store , navigate to your profile picture (in the upper right-hand corner) and click on it to view Settings. Now, scroll down and click on Settings.  Once you enter the "Settings" option. Click on it to expand other sections. Now scroll down and click on the "About" > " Play Store Version " option. If there is any pending update, it will start updating otherwise, it will state "Google Play Store is up to date".  By following these simple steps, you can easily download and install the Google Play Store on your Android device. Whether you're setting up a new device, recovering from a factory reset, or simply need to update to the latest version, these methods will ensure that your Google Play Store installation is smooth and hassle-free.
======================================================================

Link text: Breadth First Search or BFS for a Graph - GeeksforGeeks
URL: https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/
Article headline: Breadth First Search or BFS for a Graph
Last updated: 28 Aug, 2025
Description: Given a undirected graph represented by an adjacency list adj , where each adj[i] represents the list of vertices connected to vertex i . Perform a Breadth First Search (BFS) traversal starting from vertex 0 , visiting vertices from left to right according to the adjacency list, and return a list containing the BFS traversal of the graph. Examples: Input: adj[][] = [[1,2], [0,2,3], [0,1,4], [1,4], [2,3]] Output: [0, 1, 2, 3, 4] Explanation: Starting from 0, the BFS traversal will follow these steps: Visit 0 → Output: [0] Visit 1 (first neighbor of 0) → Output: [0, 1] Visit 2 (next neighbor of 0) → Output: [0, 1, 2] Visit 3 (next neighbor of 1) → Output: [0, 1, 2, 3] Visit 4 (neighbor of 2) → Final Output: [0, 1, 2, 3, 4] Input: adj[][] = [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]] Output: [0, 1, 2, 3, 4] Explanation: Starting from 0, the BFS traversal proceeds as follows: Visit 0 → Output: [0] Visit 1 (the first neighbor of 0) → Output: [0, 1] Visit 2 (the next neighbor of 0) → Output: [0, 1, 2] Visit 3 (the first neighbor of 2 that hasn't been visited yet) → Output: [0, 1, 2, 3] Visit 4 (the next neighbor of 2) → Final Output: [0, 1, 2, 3, 4] Breadth First Search (BFS) is a fundamental graph traversal algorithm. It begins with a node, then first traverses all its adjacent nodes. Once all adjacent are visited, then their adjacent are traversed. The algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to the Breadth-First Traversal of a tree . Like tree, we begin with the given source (in tree, we begin with root) and traverse vertices level by level using a queue data structure.  The only catch here is that, unlike trees,  graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a Boolean visited array.  Follow the below given approach: This algorithm ensures that all nodes in the graph are visited in a breadth-first manner, starting from the starting node. The above implementation takes a source as an input and prints only those vertices that are reachable from the source and  would not print all vertices in case of disconnected graph. Let us see the algorithm that prints all vertices without any source and  the graph maybe disconnected. The algorithm is simple, instead of calling BFS for a single vertex, we call the above implemented BFS for all not yet visited vertices one by one. Time Complexity: O(V + E), BFS explores all the vertices and edges in the graph. In the worst case, it visits every vertex and edge once. Therefore, the time complexity of BFS is O(V + E), where V and E are the number of vertices and edges in the given graph. Auxiliary Space: O(V), BFS uses a queue to keep track of the vertices that need to be visited. In the worst case, the queue can contain all the vertices in the graph. Therefore, the space complexity of BFS is O(V). BFS has various applications in graph theory and computer science, including: Problems on BFS for a Graph
======================================================================

Link text: 200+ Core Java Interview Questions and Answers (2025)
URL: https://www.geeksforgeeks.org/java-interview-questions/
Article headline: Java Interview Questions and Answers
Last updated: 23 Jul, 2025
Description: Java is one of the most popular programming languages in the world, known for its versatility, portability, and wide range of applications. Java is the most used language in top companies such as Uber, Airbnb, Google, Netflix, Instagram, Spotify, Amazon, and many more because of its features and performance. In this article, we will provide 200+ Core Java Interview Questions tailored for both freshers and experienced professionals with 3, 5, and 8 years of experience. Here, we cover everything, including core Java concepts, Object-Oriented Programming (OOP), multithreading, exception handling, design patterns, Java Collections, and more, that will surely help you to crack Java interviews. Yes, Java is a Platform Independent language. Unlike many programming languages javac compiles the program to form a bytecode or .class file. This file is independent of the software or hardware running but needs a JVM(Java Virtual Machine) file preinstalled in the operating system for further execution of the bytecode. Although JVM is platform dependent , the bytecode can be created on any System and can be executed in any other system despite hardware or software being used which makes Java platform independent. Java is one the most famous and most used language in the real world, there are many features in Java that makes it better than any other language some of them are mentioned below:   JVM stands for Java Virtual Machine it is a Java interpreter. It is responsible for loading, verifying, and executing the bytecode created in Java. Although it is platform dependent which means the software of JVM is different for different Operating Systems it plays a vital role in making Java platform Independent. To know more about the topic refer to JVM in Java .  JIT stands for (Just-in-Time) compiler is a part of JRE(Java Runtime Environment), it is used for better performance of the Java applications during run-time. The use of JIT is mentioned in step by step process mentioned below: To know more about the topic refer to JIT in Java .  JVM consists of a few memory storages as mentioned below: To know more about the topic refer to JVM Memory Storages . Classloader is the part of JRE(Java Runtime Environment), during the execution of the bytecode or created .class file classloader is responsible for dynamically loading the java classes and interfaces to JVM(Java Virtual Machine). Because of classloaders Java run time system does not need to know about files and file systems. To know more about the topic refer to ClassLoader in Java. JVM : JVM also known as Java Virtual Machine is a part of JRE. JVM is a type of interpreter responsible for converting bytecode into machine-readable code. JVM itself is platform dependent but it interprets the bytecode which is the platform-independent reason why Java is platform-independent. JRE : JRE stands for Java Runtime Environment, it is an installation package that provides an environment to run the Java program or application on any machine. JDK : JDK stands for Java Development Kit which provides the environment to develop and execute Java programs. JDK is a package that includes two things Development Tools to provide an environment to develop your Java programs and, JRE to execute Java programs or applications. To know more about the topic refer to the Differences between JVM, JRE, and JDK . Basis C++ Java Platform C++ is Platform Dependent Java is Platform Independent Application C++ is mainly used for System Programming Java is Mainly used for Application Programming Hardware C++ is nearer to hardware Java is not so interactive with hardware Global Scope C++ supports global and namespace scope. Java doesn't support global scope. Not Supporting Functionality supported in Java but not in C++ are: Functionality supported in C++ but not in Java are: OOPS C++ is an object-oriented language. It is not a single root hierarchy . Java is also an object-oriented language. It is a single root hierarchy as everything gets derived from a single class (java.lang.Object). Inheritance Tree C++ always creates a new inheritance tree. Java uses a Single inheritance tree as classes in Java are the child of object classes in Java.  Unlike any other programming language like C, C++, etc. In Java, we declared the main function as a public static void main (String args[]). The meanings of the terms are mentioned below: A Java String Pool is a place in heap memory where all the strings defined in the program are stored. A separate place in a stack is there where the variable storing the string is stored. Whenever we create a new string object, JVM checks for the presence of the object in the String pool, If String is available in the pool, the same object reference is shared with the variable, else a new object is created.  Example: We can declare the main method without using static and without getting any errors. But, the main method will not be treated as the entry point to the application or the program. Packages in Java can be defined as the grouping of related types of classes, interfaces, etc providing access to protection and namespace management. Packages are used in Java in order to prevent naming conflicts, control access, and make searching/locating and usage of classes, interfaces, etc easier. There are various advantages of defining packages in Java. There are two types of packages in Java There are 2 types of data types in Java as mentioned below: Primitive Data Type: Primitive data are single values with no special capabilities. There are 8 primitive data types: Non-Primitive Data Type: Reference Data types will contain a memory address of the variable's values because it is not able to directly store the values in the memory. Types of Non-Primitive are mentioned below: A byte is an 8-bit signed two-complement integer. The minimum value supported by bytes is -128 and 127 is the maximum value. It is used in conditions where we need to save memory and the limit of numbers needed is between -128 to 127. No, Java doesn't provide the support of Pointer. As Java needed to be more secure because which feature of the pointer is not provided in Java. The default value of the byte datatype in Java is 0. The default value of the float is 0.0f and of double is 0.0d in Java. Wrapper, in general, is referred to a larger entity that encapsulates a smaller entity. Here in Java, the wrapper class is an object class that encapsulates the primitive data types. The primitive data types are the ones from which further data types could be created. For example, integers can further lead to the construction of long, byte, short, etc. On the other hand, the string cannot, hence it is not primitive. Getting back to the wrapper class, Java contains 8 wrapper classes. They are Boolean, Byte, Short, Integer, Character, Long, Float, and Double. Further, custom wrapper classes can also be created in Java which is similar to the concept of Structure in the C programming language. We create our own wrapper class with the required data types. The wrapper class is an object class that encapsulates the primitive data types, and we need them for the following reasons: Instance Variable Local Variable Declared outside the method, directly invoked by the method. Declared within the method. Has a default value. No default value It can be used throughout the class. The scope is limited to the method. In Java When we haven’t initialized the instance variables then the compiler initializes them with default values. The default values for instances and variables depend on their data types. Some common types of default data types are: Example: Output: In Java, a class variable (also known as a static variable) is a variable that is declared within a class but outside of any method, constructor, or block. Class variables are declared with the static keyword, and they are shared by all instances (objects) of the class as well as by the class itself. No matter how many objects are derived from a class, each class variable would only exist once. Example: There is no default value stored with local variables. Also, primitive variables and objects don't have any default values. Instance Variable: A class variable without the static modifier is called an instance variable. It is unique to each object (instance) of the class and is not shared between instances. Example: Class Variable: Class Variable variable can be declared anywhere at the class level using the keyword static. These variables can only have one value when applied to various objects. These variables can be shared by all class members since they are not connected to any specific object of the class. Example: The static keyword is used to share the same variable or method of a given class. Static variables are the variables that once declared then a single copy of the variable is created and shared among all objects at the class level. System.out - It is a PrintStream that is used for writing characters or can be said it can output the data we want to write on the Command Line Interface console/terminal. Example: System.err - It is used to display error messages. Example: Output: Although, System.err have many similarities both of them have quite a lot of difference also, let us check them. It will print to the standard out of the system. It will print to the standard error. It is mostly used to display results on the console. It is mostly used to output error texts. It gives output on the console with the default(black) color. It also gives output on the console but most of the IDEs give it a red color to differentiate. System.in - It is an InputStream used to read input from the terminal Window. We can't use the System.in directly so we use Scanner class for taking input with the system.in. Example: Output:  Java brings various Streams with its I/O package that helps the user to perform all the input-output operations. These streams support all types of objects, data types, characters, files, etc to fully execute the I/O operations. The key difference between them is that byte stream data is read and written by input/output stream classes. Characters are handled by the Reader and Writer classes. In contrast to Reader/Writer classes, which accept character arrays as parameters, input/output stream class methods accept byte arrays. In comparison to input/output streams, the Reader/Writer classes are more efficient, handle all Unicode characters, and are useful for internalization. Use Reader/Writer classes instead of binary data, such as pictures, unless you do so. Example: All the stream classes can be divided into two types of classes that are ByteStream classes and CharacterStream Classes. The ByteStream classes are further divided into InputStream classes and OutputStream classes. CharacterStream classes are also divided into Reader classes and Writer classes. The SuperMost classes for all the InputStream classes is java.io.InputStream and for all the output stream classes is java.io.OutPutStream. Similarly, for all the reader classes, the super-most class is java.io.Reader, and for all the writer classes, it is java.io.Writer. To read and write data, Java offers I/O Streams. A Stream represents an input source or an output destination, which could be a file, an i/o device, another program, etc. FileInputStream in Java is used to read data from a file as a stream of bytes. It is mostly used for reading binary data such as images, audio files, or serialized objects. Example: In Java, the FileOutputStream function is used to write data byte by byte into a given file or file descriptor. Usually, raw byte data, such as pictures, is written into a file using FileOutputStream. Example: When we are working with the files or stream then to increase the Input/Output performance of the program we need to use the BufferedInputStream and BufferedOutputStream classes. These both classes provide the capability of buffering which means that the data will be stored in a buffer before writing to a file or reading it from a stream. It also reduces the number of times our OS needs to interact with the network or the disk. Buffering allows programs to write a big amount of data instead of writing it in small chunks. This also reduces the overhead of accessing the network or the disk. Stream filter or Filter Streams returns a stream consisting of the elements of this stream that match the given predicate. While working filter() it doesn't actually perform filtering but instead creates a new stream that, when traversed, contains the elements of initial streams that match the given predicate. Example: An I/O filter also defined as an Input Output filter is an object that reads from one stream and writes data to input and output sources. It used java.io package to use this filter. There are two methods to take input from the console in Java mentioned below: The program demonstrating the use of each method is given below. Example: Output: print, println, and printf all are used for printing the elements but print prints all the elements and the cursor remains in the same line. println shifts the cursor to next line. And with printf we can use format identifiers too. Operators are the special types of symbols used for performing some operations over variables and values. All types of operators in Java are mentioned below: Postfix operators are considered as the highest precedence according to Java operator precedence. Operators like >> and >>> seem to be the same but act a bit differently. >> operator shifts the sign bits and the >>> operator is used in shifting out the zero-filled bits. Example: There is only one operator which is right associative which is = operator. The Dot operator in Java is used to access the instance variables and methods of class objects. It is also used to access classes and sub-packages from the package. The covariant return type specifies that the return type may vary in the same direction as the subclass. It's possible to have different return types for an overriding method in the child class, but the child’s return type should be a subtype of the parent’s return type and because of that overriding method becomes variant with respect to the return type. We use covariant return type because of the following reasons: The transient keyword is used at the time of serialization if we don’t want to save the value of a particular variable in a file. When JVM comes across a transient keyword, it ignores the original value of the variable and saves the default value of that variable data type. Sleep() Wait() The sleep() method belongs to the thread class. Wait() method belongs to the object class. Sleep does not release the lock that the current thread holds. wait() release the lock which allows other threads to acquire it. This method is a static method. This method is not a static method. Mainly used to delay a thread for some specific time duration. Mainly used to pause a thread until notified by another thread. Sleep() Has Two Overloaded Methods: Wait() Has Three Overloaded Methods: String StringBuffer StringBuffer StringBuilder String is immutable, making it inefficient for scenarios requiring frequent updates. Instead, we can use StringBuilder or StringBuffer. If thread safety is required (synchronized operations), StringBuffer should be used. However, if performance is a priority in a single-threaded context, StringBuilder is the better choice since it is faster and does not incur synchronization overhead. StringBuffer class in Java is used to represent a changeable string of characters. It offers an alternative to the immutable String class by enabling you to change a string's contents without constantly creating new objects. Mutable (modifiable) strings are created with the help of the StringBuffer class. The StringBuffer class in Java is identical to the String class except that it is changeable. Example: String using new() is different from the literal as when we declare string it stores the elements inside the stack memory whereas when it is declared using new() it allocates a dynamic memory in the heap memory. The object gets created in the heap memory even if the same content object is present. Syntax:  An Array in Java is a data structure that is used to store a fixed-size sequence of elements of the same type. Elements of an array can be accessed by their index, which starts from 0 and goes up to a length of minus 1. Array declaration in Java is done with the help of square brackets and size is also specified during the declaration. Syntax: Arrays in Java are created in heap memory. When an array is created with the help of a new keyword, memory is allocated in the heap to store the elements of the array. In Java, the heap memory is managed by the Java Virtual Machine(JVM) and it is also shared between all threads of the Java Program. The memory which is no longer in use by the program, JVM uses a garbage collector to reclaim the memory. Arrays in Java are created dynamically which means the size of the array is determined during the runtime of the program. The size of the array is specified during the declaration of the array and it cannot be changed once the array is created. There are two types of arrays i.e., Primitive arrays and References Arrays.  Syntax: The index of an array signifies the distance from the start of the array. So, the first element has 0 distance therefore the starting index is 0. Syntax: Both int array[] and int[] array are used to declare an array of integers in java. The only difference between them is on their syntax no functionality difference is present between them. However, it is generally recommended to use Java-style syntax to declare an Array. As it is easy to read and understand also it is more consistent with other Java language constructs. In Java, there are multiple ways to copy an array based on the requirements: 1. clone() Method (Shallow Copy) 2. System.arraycopy() Method (Deep Copy) 3. Arrays.copyOf() Method (Creates New Array) 4. Arrays.copyOfRange() Method (Copying a Subset) A jagged Array in Java is just a two-dimensional array in which each row of the array can have a different length. Since all the rows in a 2-d Array have the same length but a jagged array allows more flexibility in the size of each row. This feature is very useful in conditions where the data has varying lengths or when memory usage needs to be optimized. Syntax: In Java, it is not possible to make a volatile. Volatile keywords in Java can only be applied to individual variables but not to arrays or collections. The value of the Variable is always read from and written to the main memory when it is defined as volatile rather than being cached in a thread's local memory. This makes it easier to make sure that all threads that access the variable can see changes made to it.  Paradigm literally means a pattern or a method. Programming paradigms are the methods to solve a program that is of four types namely, Imperative, logical, functional, and object-oriented. When objects are used as base entities upon which the methods are applied, encapsulation or inheritance functionalities are performed, it is known as an object-oriented paradigm. The main concepts of OOPs in Java are mentioned below: Object-Oriented Programming Language Object-Based Programming Language the new operator is used to create objects, but if we want to decide the type of object to be created at runtime, there is no way we can use the new operator. In this case, we have to use the newInstance() method . In Java, Classes are the collection of objects sharing similar characteristics and attributes. Classes represent the blueprint or template from which objects are created.  Classes are not real-world entities but help us to create objects which are real-world entities. Static(Class) method Instance method Static method is associated with a class rather than an object. The instance method is associated with an object rather than a class. Static methods can be called using the class name only without creating an instance of a class. The instance methods can be called on a specific instance of a class using the object reference. Static methods do not have access to this keyword . Instance methods have access to this keyword . Static methods can access only static members of the class. Instance methods can access both static and non-static methods of the class. Static methods cannot be overridden because they are resolved at compile time, not at run time. This means that the compiler decides which method to call based on the reference type, not on the object type. Instance methods can be overridden because they are resolved at run time, not at compile time. This means that the compiler decides which method to call based on the object type, not on the reference type.  ‘this’ is a keyword used to reference a variable that refers to the current object.  Access Specifiers in Java help to restrict the scope of a class, constructor, variable, method, or data member. There are four types of Access Specifiers in Java mentioned below: The initial value of an object reference which is defined as an instance variable is a NULL value. The object is a real-life entity that has certain properties and methods associated with it. The object is also defined as the instance of a class. An object can be declared using a new keyword. Methods to create objects in Java are mentioned below: To know more about methods to create objects in Java refer to this article . There are many advantages and disadvantages of using object cloning as mentioned below: Advantages: Disadvantages: There are a few advantages of passing this into a method instead of the current class object itself these are: Constructor is a special method that is used to initialize objects. Constructor is called when a object is created. The name of constructor is same as of the class. Example: If you don't provide a constructor in a class in Java, the compiler automatically generates a default constructor with no arguments and no operation which is a default constructor. There are two types of constructors in Java as mentioned below: Default Constructor: It is the type that does not accept any parameter value. It is used to set initial values for object attributes. Parameterized Constructor: It is the type of constructor that accepts parameters as arguments. These are used to assign values to instance variables during the initialization of objects. Constructors help to create instances of a class or can be said to create objects of a class. Constructor is called during the initialization of objects. A default constructor is a type of constructor which do not accept any parameter, So whatever value is assigned to properties of the objects are considered default values. The copy constructor is the type of constructor in which we pass another object as a parameter because which properties of both objects seem the same, that is why it seems as if constructors create a copy of an object. A private constructor is used if you don't want any other class to instantiate the object to avoid subclassing. The use private constructor can be seen as implemented in the example. Example: Java constructors are used for initializing objects. During creation, constructors are called to set attributes for objects apart from this few basic differences between them are: An interface in Java is a collection of static final variables and abstract methods that define the contract or agreement for a set of linked classes. Any class that implements an interface is required to implement a specific set of methods. It specifies the behavior that a class must exhibit but not the specifics of how it should be implemented. Syntax: Example: An Interface in Java programming language is defined as an abstract type used to specify the behavior of a class. An interface in Java is a blueprint of a behavior. A Java interface contains static constants and abstract methods. Features of the Interface are mentioned below: An Interface is recognized as an empty interface (no field or methods) it is called a marker interface. Examples of marker interfaces are Serializable, Cloneable, and Remote interfaces.  Abstract Class Interface Class Both abstract and non-abstract methods may be found in an abstract class. The interface contains only abstract methods. Abstract Class supports Final methods. The interface class does not support Final methods. Multiple inheritance is not supported by the Abstract class. Multiple inheritances is supported by Interface Class. Abstract Keyword is used to declare Abstract class. Interface Keyword is used to declare the interface class. Abstract Class has members like protected, private, etc. All class members are public by default.  Data Encapsulation is the concept of OOPS properties and characteristics of the classes that The interface is binded together. Basically, it bundles data and methods that operate on that data within a single unit. Encapsulation is achieved by declaring the instance variables of a class as private, which means they can only be accessed within the class. The advantages of Encapsulation in Java are mentioned below: The main advantage of Encapsulation in Java is its ability to protect the internal state of an object from external modification or access. It is the is a way of hiding the implementation details of a class from outside access and only exposing a public interface that can be used to interact with the class. The main benefit is of providing a way to control and manage the state and the behavior of an object and also protecting it from modification and unauthorized access at the same time. Example:  Aggregation is a term related to the relationship between two classes best described as a "has-a" relationship. This kind is the most specialized version of association. It is a unidirectional association means it is a one-way relationship. It contains the reference to another class and is said to have ownership of that class. 'IS-A' is a type of relationship in OOPs Java where one class inherits another class. When an object that belongs to a subclass acquires all the properties and behavior of a parent object that is from the superclass, it is known as inheritance.  A class within a class is called the subclass and the latter is referred to as the superclass. Sub class or the child class is said to be specific whereas the superclass or the parent class is generic. Inheritance provides code reusability. Inheritance is the method by which the Child class can inherit the features of the Super or Parent class. In Java, Inheritance is of four types: A component of the object-oriented notion known as multiple inheritances allows a class to inherit properties from many parent classes. When methods with the same signature are present in both superclasses and subclasses, an issue arises. The method's caller cannot specify to the compiler which class method should be called or even which class method should be given precedence. Note: Java doesn’t support Multiple Inheritance Example: Inheritance in C++ Inheritance in Java Yes, there is a limitation of using Inheritance in Java, as because of inheritance one can inherit everything from super class and interface because of which subclass is too clustered and sometimes error-prone when dynamic overriding or dynamic overloading is done in certain situations. Inheritance is a popular concept of Object-Oriented Programming (OOP), in which a class can inherit the properties and methods from any other class, which is referred to as a Parent or superclass. On the other hand in Composition, a class can contain an instance of another class as a member variable which is often referred to as part or a component. Below are some reasons why composition is more advantageous than inheritance: The association is a relation between two separate classes established through their Objects. It represents Has-A’s relationship. Aggregation is a relationship between two entities where one entity is associated with another, but they can exist independently. It represents a "has-a" relationship. In Aggregation, the contained object does not get destroyed when the container object is destroyed. Example: A Department has multiple Professors, but a Professor can exist independently of a Department. Composition in Java is a design principle where one class contains an instance of another class and establishes a strong relationship between them. The child object cannot exist independently of the parent object. Example: A Human has a Heart, but a Heart cannot exist without a Human. Aggregation Composition It defines a "has a" relationship between the objects It represents the part-of relationship Objects are independent of each other. Objects are dependent on each other. Represent it by using the empty diamond. Represent it by using the filled diamond. Child objects don't have a lifetime. Child objects have a lifetime. No, we can't inherit a constructor. Polymorphism is defined as the ability to take more than one form It is of two types namely, Compile time polymorphism or method overloading- a function called during compile time. For instance, take a class ‘area’. Based on the number of parameters it may calculate the area of a square, triangle, or circle. Run time polymorphism or method overriding- links during run time.  The method inside a class overrides the method of the parent class. Dynamic method dispatch is a resolving mechanism for method overriding during the run time. Method overriding is the one where the method in a subclass has the same name, parameters, and return type as a method in the superclass. When the over-ridden method is called through a superclass reference, java determines which version (superclass or subclass) of that method is to be executed based upon the type of an object being referred to at the time the call occurs. Thus the decision is made at run time. This is referred to as dynamic method dispatch. Method overriding, also known as run time polymorphism is one where the child class contains the same method as the parent class. For instance, we have a method named ‘gfg()’ in the parent class. A method gfg() is again defined in the sub-class. Thus when gfg() is called in the subclass, the method within the class id executed. Here, gfg() within the class overridden the method outside.  Method overriding is a method to achieve Run-time polymorphism in Java. Method overriding is a feature that allows a child class to provide a specific implementation of a method that is already provided by one of its parent classes. When a method in a child class has the same name, the same parameters or signature, and the same return type (or sub-type) as a method in its parent class, then the method in the subclass is said to override the method in the superclass. In Java, Method Overloading allows different methods to have the same name, but different signatures where the signature can differ by the number of input parameters or type of input parameters, or a mixture of both. Method overloading in Java is also known as Compile-time Polymorphism , Static Polymorphism, or Early binding . In Method overloading compared to the parent argument, the child argument will get the highest priority. No, as static methods are part of the class rather than the object so we can't override them. Yes, since the overloaded method is a completely different method in the eyes of the compiler. Overriding isn't the same thing at all. The decision as to which method to call is deferred to runtime. Yes in Java we can overload the main method to call the main method with the help of its predefined calling method. Method Overloading: It is also known as Compile Time Polymorphism. In method overloading two or more methods are shared in the same class with a different signature. Example: Method Overriding: Method Overriding occurs when a subclass can provide the implementation of a method which is already defined in the parent class or superclass. The return type, name and arguments must be similar to the methods in superclass. Example: Method Overloading Method Overriding When two or multiple methods are in the same class with different parameters but the same name. When a subclass provides its own implementation of a method that is already defined in the parent class. Method overloading can only happen in the same class or between a subclass or parent class. Method overriding can only happen in Subclass. When an error occurs it is caught at the compile time of the program. When an error occurs it is caught at Runtime of the program. Example of Compile Time Polymorphism. Example of Run Time Polymorphism. Method Overloading may or may not require Inheritance. Method overriding always needs Inheritance. It occurs within the class. It is performed in two classes with an inheritance relationship. It is not possible to override the private methods in Java. Method overriding is where the method in the subclass is implemented instead of the method from the parent class. The private methods are accessible only within the class in which it is declared. Since this method is not visible to other classes and cannot be accessed, it cannot be overridden. Yes, we can change the scope of an overridden method in the subclass, but only to make it wider or the same as the superclass method’s scope. We can modify the throws clause of the Superclass method with some limitations, we can change the throws clause of the superclass method while overriding it in the subclass. The subclass overridden method can only specify unchecked exceptions if the superclass method does not declare any exceptions. If the superclass method declares an exception, the subclass method can declare the same exception, a subclass exception, or no exception at all. However, the subclass method cannot declare a parent exception that is broader than the ones declared in the superclass method. Yes, Java supports virtual functions. Functions are by default virtual and can be made non-virtual using the final keyword. Abstraction refers to the act of representing essential features without including background details. The detailed information or the implementation is hidden. The most common example of abstraction is a car, we know how to turn on the engine, accelerate and move, however, the way engine works, and its internal components are complex logic hidden from the general users. This is usually done to handle the complexity. A class declared as abstract, cannot be instantiated i.e., the object cannot be created. It may or may not contain abstract methods but if a class has at least one abstract method, it must be declared abstract. Example of an abstract class with abstract method: An abstract method is used when we want to use a method but want to child classes to decide the implementation in that case we use Abstract methods with the parent classes. Serialization in the child class if the base class is implementing the Serializable interface then we can avoid it by defining the writeObject() method and throwing NotSerializableException(). Collections are units of objects in Java. The collection framework is a set of interfaces and classes in Java that are used to represent and manipulate collections of objects in a variety of ways. The collection framework contains classes(ArrayList, Vector, LinkedList, PriorityQueue, TreeSet) and multiple interfaces (Set, List, Queue, Deque) where every interface is used to store a specific type of data. Collection framework implements Collection interface: Collection is the primary interface available that can be imported using java.util.Collection. Syntax: An ArrayList can be synchronized using two methods mentioned below: Using Collections.synchronizedList(): Using CopyOnWriteArrayList: ArrayList is in need even when we have Vectors because of certain reasons: Generic arrays can't be created because an array carries type information of its elements at runtime because of which during runtime it throw 'ArrayStoreException' if the elements' type is not similar. Since generics type information gets erased at compile time by Type Erasure, the array store check would have been passed where it should have failed. The elements of a regular array in Java are stored in contiguous memory locations, meaning that each element is stored in a sequential block of memory. This allows easy access to any element by its index because the address can be calculated using the base address of the array and the size of each element In contrast, the ArrayList class implements a dynamic array, which means that its size can change as elements are added or removed. ArrayList elements are also stored in contiguous memory locations, similar to arrays. However, when an ArrayList reaches its capacity and more elements need to be added, a new, larger underlying array is created. The elements from the old array are then copied to the new one. This process ensures that the ArrayList can grow dynamically while keeping the elements in contiguous memory locations. There are multiple methods to convert List into ArrayList  Programmers can convert an Array to ArrayList using asList() method of the Arrays class. It is a static method of the Arrays class that accepts the List object. Syntax: Example:  Java programmers can convert ArrayList to Syntax: Example: Due to ArrayLists array-based nature, it grows dynamically in size ensuring that there is always enough room for elements. When an ArrayList element is first created, the default capacity is around 10-16 elements which basically depends on the Java version. ArrayList elements are copied over from the original array to the new array when the capacity of the original array is full. As the ArrayList size increases dynamically, the class creates a new array of bigger sizes and it copies all the elements from the old array to the new array. Now, the reference of the new array is used internally. This process of dynamically growing an array is known as resizing. Vectors in Java are similar and can store multiple elements inside them. Vectors follow certain rules mentioned below: Syntax: An ArrayList can be made ready only using the method provided by Collections using the Collections.unmodifiableList() method. Syntax: Example:  A priority queue is an abstract data type similar to a regular queue or stack data structure. Elements stored in elements are depending upon the priority defined from low to high. The PriorityQueue is based on the priority heap. Syntax: LinkedList class is Java that uses a doubly linked list to store elements. It inherits the AbstractList class and implements List and Deque interfaces. Properties of the LinkedList Class are mentioned below: Syntax: A Stack class in Java is a LIFO data structure that implements the Last In First Out data structure. It is derived from a Vector class but has functions specific to stacks. The Stack class in java provides the following methods: Sets are collections that don't store duplicate elements. They don't keep any order of the elements. The Java Collections framework provides several implementations of the Set interface, including: The HashSet class implements the Set interface in the Java Collections Framework and is a member of the HashSet class. Unlike duplicate values, it stores a collection of distinct elements. In this implementation, each element is mapped to an index in an array using a hash function, and the index is used to quickly access the element. It produces an index for the element in the array where it is stored based on the input element. Assuming the hash function distributes the elements among the buckets appropriately, the HashSet class provides constant-time performance for basic operations (add, remove, contain, and size). The LinkedHashSet is an ordered version of Hashset maintained by a doubly-linked List across all the elements. It is very helpful when iteration order is needed. During Iteration in LinkedHashSet, elements are returned in the same order they are inserted. Syntax: Example:  The map interface is present in the Java collection and can be used with Java.util package. A map interface is used for mapping values in the form of a key-value form. The map contains all unique keys. Also, it provides methods associated with it like containsKey(), contains value (), etc. There are multiple types of maps in the map interface as mentioned below: TreeMap is a type of map that stores data in the form of key-value pair. It is implemented using the red-black tree. Features of TreeMap are : EnumSet is a specialized implementation of the Set interface for use with enumeration type. A few features of EnumSet are: Syntax: Parameter: E specifies the elements.  A blocking queue is a Queue that supports the operations that wait for the queue to become non-empty while retrieving and removing the element, and wait for space to become available in the queue while adding the element. Syntax: Parameters: E is the type of elements stored in the Collection ConcurrentHashMap is implemented using Hashtable. Syntax: Parameters : K is the key Object type and V is the value Object type Yes, we can use any class as a Map Key if it follows certain predefined rules mentioned below:  The Iterator interface provides methods to iterate over any Collection in Java. Iterator is the replacement of Enumeration in the Java Collections Framework. It can get an iterator instance from a Collection using the _iterator()_ method.  It also allows the caller to remove elements from the underlying collection during the iteration. Enumeration is a user-defined data type. It is mainly used to assign names to integral constants, the names make a program easy to read and maintain. The main objective of the enum is to define user-defined data types. Example: Collection Collections The Collection is an Interface. Collections is a class. It provides the standard functionality of data structure. It is to sort and synchronize the collection elements. It provides the methods that can be used for the data structure. It provides static methods that can be used for various operations. Array ArrayList Single-dimensional or multidimensional Single-dimensional For and for each used for iteration Here iterator is used to traverse riverArrayList length keyword returns the size of the array. size() method is used to compute the size of ArrayList. The array has Fixed-size. ArrayList size is dynamic and can be increased or decreased in size when required. It is faster as above we see it of fixed size It is relatively slower because of its dynamic nature Primitive data types can be stored directly in unlikely objects. Primitive data types are not directly added to unlikely arrays, they are added indirectly with help of autoboxing and unboxing They can not be added here hence the type is in the unsafe. They can be added here hence makingArrayList type-safe. The assignment operator only serves the purpose Here a special method is used known as add() method Array Collections Array in Java has a fixed size. Collections in Java have dynamic sizes. In an Array, Elements are stored in contiguous memory locations. In Collections, Elements are not necessarily stored in contiguous memory locations. Objects and primitive data types can be stored in an array. We can only store objects in collections. Manual manipulation is required for resizing the array. Resizing in collections is handled automatically. The array has basic methods for manipulation. Collections have advanced methods for manipulation and iteration. The array is available since the beginning of Java. Collections were introduced in Java 1.2. ArrayList LinkedList ArrayList is Implemented as an expandable Array. LinkedList is Implemented as a doubly-linked list. In ArrayList, Elements are stored in contiguous memory locations LinkedList Elements are stored in non-contiguous memory locations as each element has a reference to the next and previous elements. ArrayLists are faster for random access. LinkedLists are faster for insertion and deletion operations ArrayLists are more memory efficient. LinkedList is less memory efficient ArrayLists Use more memory due to maintaining the array size. LinkedList Uses less memory as it only has references to elements The search operation is faster in ArrayList. The search operation is slower in LinkedList ArrayList Vector ArrayList is i mplemented as a resizable array. Vector is i mplemented as a synchronized, resizable array. ArrayList is not synchronized. The vector is synchronized. ArrayLists are Faster for non-concurrent operations. Vector is Slower for non-concurrent operations due to added overhead of synchronization. ArrayLists were Introduced in Java 1.2. Vector was Introduced in JDK 1.0. Recommended for use in a single-threaded environment. Vectors are Recommended for use in a multi-threaded environment. The default initial capacity of ArrayLists is 10. In Vectors, the default initial capacity is 10 but the default increment is twice the size. ArrayList performance is high. Vector performance is low. Iterator ListIterator Can traverse elements present in Collection only in the forward direction. Can traverse elements present in Collection both in forward and backward directions. Used to traverse Map, List, and Set. Can only traverse List and not the other two. Indexes can't be obtained using Iterator It has methods like nextIndex() and previousIndex() to obtain indexes of elements at any time while traversing the List. Can't modify or replace elements present in Collection Can modify or replace elements with the help of set(E e) Can't add elements, and also throws ConcurrentModificationException. Can easily add elements to a collection at any time. Certain methods of Iterator are next(), remove(), and hasNext(). Certain methods of ListIterator are next(), previous(), hasNext(), hasPrevious(), add(E e). HashMap HashTable HashMap is not synchronized HashTable is synchronized One key can be a NULL value NULL values not allowed The iterator is used to traverse HashMap. Both Iterator and Enumertar can be used HashMap is faster. HashTable is slower as compared to HashMap. Iterator Enumeration The Iterator can traverse both legacies as well as non-legacy elements. Enumeration can traverse only legacy elements. The Iterator is fail-fast. Enumeration is not fail-fast. The Iterators are slower. Enumeration is faster. The Iterator can perform a remove operation while traversing the collection. The Enumeration can perform only traverse operations on the collection. Comparable Comparator The interface is present in java.lang package. The Interface is present in java.util package. Provides compareTo() method to sort elements. Provides compare() method to sort elements. It provides single sorting sequences. It provides multiple sorting sequences. The logic of sorting must be in the same class whose object you are going to sort. The logic of sorting should be in a separate class to write different sorting based on different attributes of objects. Method sorts the data according to fixed sorting order. Method sorts the data according to the customized sorting order. It affects the original class. It doesn't affect the original class. Implemented frequently in the API by Calendar, Wrapper classes, Date, and String. It is implemented to sort instances of third-party classes. Set Map The Set interface is implemented using java.util package. The map is implemented using java.util package. It can extend the collection interface. It does not extend the collection interface. It does not allow duplicate values. It allows duplicate values. The set can sort only one null value. The map can sort multiple null values. A FailFast iterator is an iterator that throws a ConcurrentModificationException if it detects that the underlying collection has been modified while the iterator is being used. This is the default behavior of iterators in the Java Collections Framework. For example, the iterator for a HashMap is FailFast. Example: Output: A FailSafe iterator does not throw a ConcurrentModificationException if the underlying collection is modified while the iterator is being used. Alternatively, it creates a snapshot of the collection at the time the iterator is created and iterates over the snapshot. For example, the iterator for a ConcurrentHashMap is FailSafe. Example: An Exception is an Event that interrupts the normal flow of the program and requires special processing. During the execution of a program, errors and unplanned occurrences can be dealt with by using the Java Exception Handling mechanism. Below are some reasons why Exceptions occur in Java:  There are generally two types of exceptions in Java: Errors Exceptions Recovering from Errors is not possible. Recover from exceptions by either using a try-catch block or throwing exceptions back to the caller. Errors are all unchecked types in Java. It includes both checked as well as unchecked types that occur. Errors are mostly caused by the environment in which the program is running. The program is mostly responsible for causing exceptions. Errors can occur at compile time as well as run time. Compile Time: Syntax Error, Run Time: Logical Error. All exceptions occur at runtime but checked exceptions are known to the compiler while unchecked are not. They are defined in java.lang.Error package. They are defined in java.lang.Exception package Examples : java.lang.StackOverflowError, java.lang.OutOfMemoryError Examples : Checked Exceptions: SQLException, IOException Unchecked Exceptions: ArrayIndexOutOfBoundException, NullPointerException, ArithmeticException.  All exception and error types in Java are subclasses of the class throwable, which is the base class of the hierarchy. This class is then used for exceptional conditions that user programs should catch. NullPointerException is an example of such an exception. Another branch, error is used by the Java run-time system to indicate errors having to do with the JRE. StackOverflowError is an example of one of such error. Runtime Exceptions are exceptions that occur during the execution of a code, as opposed to compile-time exceptions that occur during compilation. Runtime exceptions are unchecked exceptions, as they aren't accounted for by the JVM. Examples of runtime exceptions in Java include: Unlike checked exceptions, runtime exceptions do not require a declaration in the throws clause or capture in a try-catch block. However, handling runtime exceptions is advisable in order to provide meaningful error messages and prevent a system crash. Because runtime exceptions provide more specific information about the problem than checked exceptions, they enable developers to detect and correct programming errors more easily and quickly. It is a type of run-time exception that is thrown when the program attempts to use an object reference that has a null value. The main use of NullPointerException is to indicate that no value is assigned to a reference variable, also it is used for implementing data structures like linked lists and trees. ArrayStoreException is thrown when an attempt is made to store the wrong type of object in an array of objects. Example: Example: Checked Exceptions are the exceptions that are checked during compile time of a program. In a program, if some code within a method throws a checked exception, then the method must either handle the exception or must specify the exception using the throws keyword. Checked exceptions are of two types: Unchecked are the exceptions that are not checked at compile time of a program. Exceptions under Error and RuntimeException classes are unchecked exceptions, everything else under throwable is checked.  Error is an illegal operation performed by the user which causes abnormality in the program. Exceptions are the unexpected events or conditions that comes while running the program, exception disrupts the normal flow of the program’s instructions. Errors and Exceptions both have a common parent class which is java.lang.Throwable class. No, It is not necessary to use catch block after try block in Java as we can create another combination with finally block. Finally is the block which runs despite the fact that the exception is thrown or not. Exception propagation is a process in which the exception is dropped from to the top to the bottom of the stack. If not caught once, the exception again drops down to the previous method, and so on until it gets caught or until it reaches the very bottom of the call stack. System.exit(int) has the capability to throw SecurityException. So, if in case of security, the exception is thrown then finally block will be executed otherwise JVM will be closed while calling System. exit(0) because of which finally block will not be executed. It is the process of creating an exact copy of any object. In order to support this, a java class has to implement the Cloneable interface of java.lang package and override the clone() method provided by the Object class the syntax of which is: Protected Object clone() throws CloneNotSupportedException{ return (Object)super.clone();}In case the Cloneable interface is not implemented and just the method is overridden, it results in CloneNotSupportedException in Java. Exceptions are responsible for abruptly terminating the running of the program while executing and the code written after the exception occurs is not executed. The final keyword is used to make functions non-virtual. By default, all the functions are virtual so to make it non-virtual we use the final keyword. final is a keyword is used with the variable, method, or class so that they can't be overridden. Example: Output: finally is a block of code used with "try-catch" in exception handling. Code written in finally block runs despite the fact exception is thrown or not. Example: It is a method that is called just before deleting/destructing the objects which are eligible for Garbage collection to perform clean-up activity. Example: this( ) super( ) It represents the current instance of the class. It represents the current instance of the parent class. Calls the default constructor of the same class. Calls the default constructor of the base class. Access the methods of the same class. Access the methods of the parent class. Points current class instance. Points the superclass instance. Multitasking in Java refers to a program's capacity to carry out several tasks at once. Threads, which are quick operations contained within a single program, can do this. Executing numerous things at once is known as multitasking. Example: Multithreaded programs in Java contain threads that run concurrently instead of running sequentially. A computer can use its resources more efficiently by combining multiple tasks at once. Any program with multithreading allows more than one user to simultaneously use the program without running multiple copies. A multithreaded program is designed to run multiple processes at the same time which can improve the performance of a program and allows the program to utilize multiple processors and improves the overall throughput. There are multiple advantages of using multithreading which are as follows: Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of the CPU. In general, threads are small, lightweight processes with separate paths of execution. These threads use shared memory, but they act independently, thus if any one thread fails it does not affect the other threads. There are two ways to create a thread: We create a class that extends the java.lang.Thread class . This class overrides the run() method available in the Thread class. A thread begins its life inside run() method. Syntax: We create a new class that implements java.lang.Runnable interface and override run() method. Then we instantiate a Thread object and call the start() method on this object. Syntax: Threads in Java are subprocess with lightweight with the smallest unit of processes and also has separate paths of execution. These threads use shared memory but they act independently hence if there is an exception in threads that do not affect the working of other threads despite them sharing the same memory. A thread has its own program counter, execution stack, and local variables, but it shares the same memory space with other threads in the same process. Java provides built-in support for multithreading through the Runnable interface and the Thread class . A process and a thread are both units of execution in a computer system, but they are different in several ways: Process Thread A process is a program in execution. A thread is a single sequence of instructions within a process. The process takes more time to terminate. The thread takes less time to terminate. The process takes more time for context switching. The thread takes less time for context switching. The process is less efficient in terms of communication. Thread is more efficient in terms of communication. The process is isolated. Threads share memory. The process has its own Process Control Block, Stack, and Address Space. Thread has Parents’ PCB, its own Thread Control Block, and Stack and common Address space. The process does not share data with each other. Threads share data with each other.  A thread in Java at any point in time exists in any one of the following states. A thread lies only in one of the shown states at any instant: The suspend() method of the Thread class in Java temporarily suspends the execution of a thread. When a thread is suspended it goes into a blocked state and it would not be scheduled by the operating system which means that it will not be able to execute its task until it is resumed. There are more safer and flexible alternatives to the suspend() methods in the modern java programming language. This method does not return any value. Syntax: Example: Output: Java provides built-in support for multithreaded programming. The main thread is considered the parent thread of all the other threads that are created during the program execution. The main thread is automatically created when the program starts running. This thread executes the main method of the program. It is responsible for executing the main logic of the Java program as well as handling the user input operations. The main thread serves as the base thread from which all other child threads are spawned.  A daemon thread in Java is a low-priority thread that is used to perform background operations or tasks which are used to perform continuously. such as Garbage collection, Signal dispatches, Action listeners, etc. Daemon threads in Java have lower priority than user threads, which means they can only execute when no user threads are running. Daemon threads in Java are useful features that are required for background tasks that do not require explicit shutdown or finalization. It allows more efficient use of system resource and are used to simplify resources and can simplify long-running tasks. Thread is a lightweight process that runs concurrently with the other thread inside a single process. Each thread can execute a different task and share the resources within a single process. Thread in Java can enter the waiting state in many different ways: Java uses a technique called time-sharing, commonly referred to as time-slicing, to implement multi-threading on computers with a single CPU. The appearance of parallel execution is created by the CPU switching between active threads. The operating system is in charge of allocating CPU time to each thread sequentially and scheduling the threads. In order to stop threads from interacting with one another and creating race situations or other issues, Java has a number of ways to govern the behavior of threads, including synchronization and locking. It is feasible to create multi-threaded programmers that operate correctly and effectively on a machine with a single CPU by regulating the interaction between threads and making sure that crucial code parts are synchronized. In contrast to running the same program on a computer with multiple CPUs or cores, multi-threading on a single CPU can only give the appearance of parallelism, and actual performance gains may be modest. The operating system divides the CPU time that is available when numerous threads are running on a single CPU into small time slices and gives each thread a time slice to execute. Rapid switching between the threads by the operating system creates the appearance of parallel execution. The switching between threads appears to be immediate because the time slices are often very tiny, on the order of milliseconds or microseconds. Priorities in threads is a concept where every thread is having a priority which in layman’s language one can say every object is having priority here which is represented by numbers ranging from 1 to 10. There are different types of thread properties in Java mentioned below: By default, the thread is assigned NORM_PRIORITY. For Java, Garbage collection is necessary to avoid memory leaks which can cause the program to crash and become unstable. There is no way to avoid garbage collection in Java. Unlike C++, Garbage collection in Java helps programmers to focus on the development of the application instead of managing memory resources and worrying about memory leakage. Java Virtual Machine (JVM) automatically manages the memory periodically by running a garbage collector which frees up the unused memory in the application. Garbage collection makes Java memory efficient because it removes unreferenced objects from the heap memory. Apart from many advantages, Garbage Collector has certain drawbacks mentioned below: The Java Virtual Machine (JVM) removes objects that are no longer in use using a garbage collector which periodically checks and removes these objects. There are different types of garbage collection in the JVM, each with different characteristics and performance implications. The main types of garbage collection are: Major garbage collection works on the survivor space and Minor garbage collection works on the Eden space to perform a mark-and-sweep routine. And we can identify both of them based on the output where the minor collection prints "GC", whereas the major collection prints "Full GC" for the case where the garbage collection logging is enabled with "-XX:PrintGCDetails" or "verbose:gc". In Java Memory leaks can be caused by a variety of factors, such as not closing resources properly, holding onto object references longer than necessary, or creating too many objects unnecessarily. There are situations in which garbage collector does not collect objects because there is a reference to those objects. In these situations where the application creates lots of objects and does not use them and every object has some valid references, a Garbage collector in Java cannot destroy the objects. These useless objects which do not provide any value to the program are known as Memory leaks. Memory leaks can impact garbage collection negatively by preventing the garbage collector from reclaiming unused memory. This behavior will lead to slow performance or sometimes system failure. In a program, it is important to avoid memory leaks by managing resources and object references properly. Example: Output: Regular Expressions or Regex in Java is an API used for searching and manipulating of strings in Java. It creates String patterns that can extract the data needed from the strings or can generalize a pattern. There are 3 Classes present in java.util.regex mentioned below: Also, apart from the 3 classes package consists of a single interface MatchResult Interface which can be used for representing the result of a match operation. Explanation: JDBC standard API is used to link Java applications and relational databases. It provides a collection of classes and interfaces that let programmers to use the Java programming language to communicate with the database. The classes and interface of JDBC allow the application to send requests which are made by users to the specified database. There are generally four components of JDBC by which it interacts with the database:  JDBC Driver is a software component that is used to enable a Java application to interact with the database. JDBC provides the implementation of the JDBC API for a specific database management system, which allows it to connect the database, execute SQL statements and retrieve data. There are four types of JDBC drivers:  There are certain steps to connect the database and Java Program as mentioned below: JDBC API components provide various methods and interfaces for easy communication with the databases also it provides packages like java Se and java EE which provides the capability of write once run anywhere (WORA). Syntax: Java database connectivity interface (JDBC) is a software component that allows Java applications to interact with databases. To enhance the connection, JDBC requires drivers for each database. JDBC ResultSet interface is used to store the data from the database and use it in our Java Program. We can also use ResultSet to update the data using updateXXX() methods. ResultSet object points the cursor before the first row of the result data. Using the next() method, we can iterate through the ResultSet. A JDBC RowSet provides a way to store the data in tabular form. RowSet is an interface in java that can be used within the java.sql package. The connection between the RowSet object and the data source is maintained throughout its life cycle. RowSets are classified into five categories based on implementation mentioned below: JDBC DriverManager class acts as an interface for users and Drivers. It is used in many ways as mentioned below: Iterable Iterator Iterable provides a way to iterate over a sequence of elements. Iterator helps in iterating over a collection of elements sequentially. Examples are List, Queue, and Set. Examples are ListIterator, Enumeration, and ArrayIterator. List Set Ordered Unordered List allows duplicates. Set does not allow duplicate values. List is accessed by index. Set is accessed by hashcode. Multiple null elements can be stored. Null element can store only once. Examples are ArrayList, LinkedList, etc. Examples are HashSet and TreeSet. LinkedHashSet etc. List Map List interface allows duplicate elements. Map does not allow duplicate elements. List maintains insertion order. Map do not maintain insertion order. Multiple null elements can be stored. The map allows a single null key at most and any number of null values. The list provides get() method to get the element at a specified index. The map does not provide a get method to get the elements at a specified index. List is Implemented by ArrayList, etc. Map is Implemented by HashMap, TreeMap, LinkedHashMap Queue Stack Queue data structure is used to store elements, and is used to perform operations like enqueue, dequeue from back or end of the queue. Stack data structure is used to store elements, and is used to perform operations like push, pop from top of the stack. Queue data structure Implements FIFO order. Stack data structure Implements LIFO order. Insertion and deletion in queues take place from the opposite ends of the list. Deletion takes place from the front of the list and insertion takes place at the rear of the list. Insertion and deletion in stacks take place only from one end of the list called the top. Insert operation is called enqueue operation. Insert operation is called Push operation. Queue is generally used to solve problems related to sequential processing. Stack is generally used to solve problems related to recursion. Priority Queue TreeSet It uses Queue as an underlying data structure. It uses a Set as an underlying data structure. This data structure allows duplicate elements This data structure does not allow duplicate elements Priority Queue is Implemented by PriorityQueue class. TreeSet is implemented by TreeSet class. PriorityQueue comes in JDK 1.5. TreeSet comes in JDK 1.4. PriorityQueue<Integer> pq = new PriorityQueue<>(); reeSet<Integer> ts = new TreeSet<>(); Singly Linked List Doubly Linked List Singly Linked List contain only two segments i.e, Data and Link. Doubly Linked List contains three segments i.e, Data, and two pointers. Traversal in a singly linked list is possible in only a forward direction. Traversal in a doubly linked list is only possible in both directions forward as well as backward. It uses less memory as every single node has only one pointer. It requires more memory than a singly linked list as each node has two pointers. Easy to use and insert nodes at the beginning of the list. Slightly more complex to use and easy to insert at the end of the list. Insertion and deletion at the head take O(1), but at any other position, they require traversal, making them O(n). Insertion and deletion at the start or end take O(1) (if head and tail pointers are maintained). However, operations at arbitrary positions require O(n) time due to traversal. FailFast FailSafe Failsfast fails immediately when it detects concurrent modification during the time of iteration. Failsafe continues to iterate over the original collection and also creates a copy to modify. Failfast is generally used in single-threaded environments. Failsafe is used in multithreaded environments. Failfast does not allow any modification while iteration. Failsafe allows modification during the time of iteration. Failfast is fast compared to failsafe as it does not involve the copying of the collection. Failsafe is generally slow compared to failfast. FailFast throws ConcurrentModificationException if the collection is modified during iteration.  FailSafe does not throws any exception but instead, it creates a copy of the collection to iterate. HashMap TreeMap Hasmap uses a hashtable in order to store key-value pairs. Treemap uses Red-black trees to store key-value pair. Hashmap does not maintain any specific order for key-value pairs. Treemap maintains a natural ordering based on the keys. Order of iteration is not guaranteed in the hashmap. Iteration is of sorted order based on keys. Hashmaps are faster for retrieval compared to Treemap. Retrieval in Treemap is slower as it uses tree traversal to find keys. Hashmap is implemented by using an Array of linked list. TreeMap is implemented using a Red-black Tree. Hashmap uses the equals() method of the Object class to compare keys. TreeMap uses compareTo() method to compare keys. Queue Deque The queue is a linear Data structure that is used to store a collection of elements. Deque also known as a Double-ended queue is also a linear data structure that stores a collection of elements with operations to remove and add from both ends. Elements in the queue can only be inserted at the end of the data structure. Elements can be inserted from both ends of the data structure. Queue can be implemented using Array or Linked List. Dequeue can be implemented using Circular Array or Doubly Linked List. Queues are generally used to implement a waiting list or task queue. Deque is used to implement a stack or dequeuing elements from both ends. HashSet TreeSet HashSet is unordered. TreeSet is based on natural ordering. HashSet allows null elements. TreeSet does not allow null elements. HashSet is Implemented by the HashSet class. TreeSet is Implemented by TreeSet class. HashSet<String> hs = new HashSet<>(); TreeSet<String> ts = new TreeSet<>();
======================================================================

Link text: Find Shortest Paths from Source to all Vertices using Dijkstra’s Algorithm
URL: https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/
Article headline: Dijkstra's Algorithm to find Shortest Paths from a Source to all
Last updated: 23 Jul, 2025
Description: Given a weighted undirected graph represented as an edge list and a source vertex src , find the shortest path distances from the source vertex to all other vertices in the graph. The graph contains V vertices, numbered from 0 to V - 1 . Note: The given graph does not contain any negative edge. Examples: Input: src = 0, V = 5, edges[][] = [[0, 1, 4], [0, 2, 8], [1, 4, 6], [2, 3, 2], [3, 4, 10]] Output: 0 4 8 10 10 Explanation: Shortest Paths: 0 to 1 = 4. 0 → 1 0 to 2 = 8. 0 → 2 0 to 3 = 10. 0 → 2 → 3 0 to 4 = 10. 0 → 1 → 4 In Dijkstra's Algorithm, the goal is to find the shortest distance from a given source node to all other nodes in the graph. As the source node is the starting point, its distance is initialized to zero. From there, we iteratively pick the unprocessed node with the minimum distance from the source, this is where a min-heap (priority queue) or a set is typically used for efficiency. For each picked node u, we update the distance to its neighbors v using the formula: dist[v] = dist[u] + weight[u][v], but only if this new path offers a shorter distance than the current known one. This process continues until all nodes have been processed. Step-by-Step Implementation Illustration:  Time Complexity: O(E*logV), Where E is the number of edges and V is the number of vertices. Auxiliary Space: O(V), Where V is the number of vertices, We do not count the adjacency list in auxiliary space as it is necessary for representing the input graph.
======================================================================

Link text: Selection Sort - GeeksforGeeks
URL: https://www.geeksforgeeks.org/selection-sort-algorithm-2/
Article headline: Selection Sort
Last updated: 23 Jul, 2025
Description: Selection Sort is a comparison-based sorting algorithm. It sorts an array by repeatedly selecting the smallest (or largest) element from the unsorted portion and swapping it with the first unsorted element. This process continues until the entire array is sorted. Time Complexity: O(n 2 ) ,as there are two nested loops: Auxiliary Space: O(1) as the only extra memory used is for temporary variables. Question 1: Is Selection Sort a stable sorting algorithm? Answer: No, Selection Sort is not stable as it may change the relative order of equal elements. Question 2: What is the time complexity of Selection Sort? Answer: Selection Sort has a time complexity of O(n^2) in the best, average, and worst cases. Question 3: Does Selection Sort require extra memory? Answer: No, Selection Sort is an in-place sorting algorithm and requires only O(1) additional space. Question 4: When is it best to use Selection Sort? Answer: Selection Sort is best used for small datasets, educational purposes, or when memory usage needs to be minimal. Question 5: How does Selection Sort differ from Bubble Sort? Answer: Selection Sort selects the minimum element and places it in the correct position with fewer swaps, while Bubble Sort repeatedly swaps adjacent elements to sort the array.
======================================================================

Link text: Software Development Life Cycle (SDLC) - GeeksforGeeks
URL: https://www.geeksforgeeks.org/software-development-life-cycle-sdlc/
Article headline: Software Development Life Cycle (SDLC)
Last updated: 14 Jul, 2025
Description: Software Development Life Cycle (SDLC) is a structured process that is used to design, develop, and test high-quality software. SDLC, or software development life cycle, is a methodology that defines the entire procedure of software development step-by-step. The goal of the SDLC life cycle model is to deliver high-quality, maintainable software that meets the user's requirements. SDLC in software engineering models outlines the plan for each stage so that each stage of the software development model can perform its task efficiently to deliver the software at a low cost within a given time frame that meets users requirements. In this article we will see Software Development Life Cycle (SDLC) in detail. SDLC is a process followed for software building within a software organization. SDLC consists of a precise plan that describes how to develop, maintain, replace, and enhance specific software. The life cycle defines a method for improving the quality of software and the all-around development process. SDLC specifies the tasks to be performed at various stages by a software engineer or developer. It ensures that the end product is able to meet the customer's expectations and fits within the overall budget. Hence, it's vital for a software developer to have prior knowledge of this software development process. SDLC is a collection of these six stages, and the stages of SDLC are as follows: The SDLC Model involves six phases or stages while developing any software. Planning is a crucial step in everything, just as in software development . In this same stage, requirement analysis is also performed by the developers of the organization. This is attained from customer inputs, and sales department/market surveys. The information from this analysis forms the building blocks of a basic project. The quality of the project is a result of planning. Thus, in this stage, the basic project is designed with all the available information. In this stage, all the requirements for the target software are specified. These requirements get approval from customers, market analysts, and stakeholders. This is fulfilled by utilizing SRS (Software Requirement Specification). This is a sort of document that specifies all those things that need to be defined and created during the entire project cycle. SRS is a reference for software designers to come up with the best architecture for the software. Hence, with the requirements defined in SRS, multiple designs for the product architecture are present in the Design Document Specification (DDS). This DDS is assessed by market analysts and stakeholders. After evaluating all the possible factors, the most practical and logical design is chosen for development. At this stage, the fundamental development of the product starts. For this, developers use a specific programming code as per the design in the DDS. Hence, it is important for the coders to follow the protocols set by the association. Conventional programming tools like compilers, interpreters, debuggers, etc. are also put into use at this stage. Some popular languages like C/C++, Python, Java, etc. are put into use as per the software regulations. After the development of the product, testing of the software is necessary to ensure its smooth execution. Although, minimal testing is conducted at every stage of SDLC. Therefore, at this stage, all the probable flaws are tracked, fixed, and retested. This ensures that the product confronts the quality requirements of SRS. Documentation, Training, and Support: Software documentation is an essential part of the software development life cycle. A well-written document acts as a tool and means to information repository necessary to know about software processes, functions, and maintenance. Documentation also provides information about how to use the product. Training in an attempt to improve the current or future employee performance by increasing an employee's ability to work through learning, usually by changing his attitude and developing his skills and understanding. After detailed testing, the conclusive product is released in phases as per the organization’s strategy. Then it is tested in a real industrial environment. It is important to ensure its smooth performance. If it performs well, the organization sends out the product as a whole. After retrieving beneficial feedback, the company releases it as it is or with auxiliary improvements to make it further helpful for the customers. However, this alone is not enough. Therefore, along with the deployment, the product's supervision . Software Development Models are structured frameworks that guide the planning, execution, and delivery of software projects. They define the sequence of development stages , such as requirements, design, coding, testing, and deployment. Read More - Most Popular SDLC Models . SDLC is a method, approach, or process that is followed by a software development organization while developing any software. SDLC models were introduced to follow a disciplined and systematic method while designing software. With the software development life cycle, the process of software design is divided into small parts, which makes the problem more understandable and easier to solve. SDLC comprises a detailed description or step-by-step plan for designing, developing, testing, and maintaining the software. Follow the project Library Management System or E Portfolio Website to see the use of Software Development Life Cycle in a Software Projects. A frequent issue in software development is the delay of security-related tasks until the testing phase, which occurs late in the software development life cycle (SDLC) and occurs after the majority of crucial design and implementation has been finished. During the testing phase, security checks may be minimal and restricted to scanning and penetration testing, which may fail to identify more complicated security flaws. Security issue can be address in SDLC by following DevOps. Security is integrated throughout the whole SDLC, from build to production, through the use of DevSecOps. Everyone involved in the DevOps value chain have responsibility for security under DevSecOps. Developing a banking application using SDLC: In conclusion, we now know that the Software Development Life Cycle (SDLC) in software engineering is an important framework for the better and more structured development of optimized software programs. In a world full of rapid evolution in technology, SDLC phases plays a crucial role in enabling some good and innovative solutions for helping users and organizations. Also, it's better to adapt SDLC principles to achieve software development goals effectively. (A) Spiral model (B) Prototyping model (C) Waterfall model (D) Capability maturity model Solution: The correct Answer is (D) . (A) P-3, Q-2, R-4, S-1 (B) P-2, Q-3, R-1, S-4 (C) P-3, Q-2, R-1, S-4 (D) P-2, Q-3, R-4, S-1 Solution: The correct Answer is (B) .
======================================================================

Link text: Python Tkinter - GeeksforGeeks
URL: https://www.geeksforgeeks.org/python-gui-tkinter/
Article headline: Python Tkinter
Last updated: 04 Aug, 2025
Description: Tkinter is Python’s built-in library for creating graphical user interfaces (GUIs). It acts as a lightweight wrapper around Tcl/Tk GUI toolkit, offering Python developers a simple and intuitive way to build desktop applications. It supports layout management, event handling and customization, making it ideal for rapid GUI development in Python. To create a Tkinter Python app, follow these basic steps: There are two main methods used which user needs to remember while creating the Python application with GUI. These methods are: To create a main window in Tkinter, we use the Tk() class. Syntax: root = Tk(screenName=None, baseName=None, className='Tk', useTk=1) Parameter: The mainloop() method is used to run application once it is ready. It is an infinite loop that keeps application running, waits for events to occur (such as button clicks) and processes these events as long as window is not closed. Example: This code initializes a basic GUI window using Tkinter. The tkinter.Tk() function creates main application window, mainloop() method starts event loop, which keeps the window running and responsive to user interactions. Output  There are a number of tkinter widgets which we can put in our tkinter application. Some of the major widgets are explained below: It refers to the display box where we display text or image. It can have various options like font, background, foreground, etc. Syntax: w=Label(master, option=value) Parameter: master used to represent parent window. Example: This code creates a simple GUI window using Tkinter that displays a text label. It imports all Tkinter classes, initializes  main window (root), adds a Label widget with text "GeeksForGeeks.org!", packs label into window. Output:  Note: We have a number of options and parameters that we can pass to widgets, only some them are used in the examples given in this article. A clickable button that can trigger an action. Syntax: w=Button(master, option=value) Example: This code creates a window titled "Counting Seconds" with a single "Stop" button. When button is clicked, window closes. It demonstrates how to set a window title, create a button widget and assign a command to terminate the application. Output: It is used to input the single line text entry from the user. For multi-line text input, Text widget is used. Syntax: w=Entry(master, option=value) Example: This code creates a form with two labeled input fields: First Name and Last Name. It uses Label widgets to display field names and Entry widgets to accept user input. The grid() geometry manager arranges the labels and entry fields in a tabular layout. Output: A checkbox can be toggled on or off. It can be linked to a variable to store its state. Syntax: w = CheckButton(master, option=value) Example: This code creates a window with two checkboxes labeled "male" and "female". It uses Checkbutton widgets linked to IntVar() variables to store checked state (1 for checked, 0 for unchecked). The grid() method arranges checkboxes vertically with left alignment using sticky=W. Output: It allows user to select one option from a set of choices. They are grouped by sharing the same variable. Syntax: w = RadioButton(master, option=value) Example: This code creates a window with two radio buttons labeled "GfG" and "MIT".  Radio buttons are linked to same IntVar() variable v ensuring only one can be selected at a time. The selected option sets v to its respective value (1 or 2) and  buttons are vertically aligned to left using pack(anchor=W). Output It displays a list of items from which a user can select one or more. Syntax: w = Listbox(master, option=value) Example: This code creates a window with a Listbox widget that displays a list of programming languages. The insert() method adds each item to Listbox at specified index and pack() displays Listbox in the window. The GUI runs using mainloop(). Output It refers to the slide controller which will be used to implement listed widgets. Syntax: w = Scrollbar(master, option=value) Example: This code creates a Listbox containing 100 lines of text and a vertical Scrollbar. The Scrollbar is linked to Listbox using yscrollcommand and command, allowing user to scroll through long list of items. The list is packed on left and fills the window, while the scrollbar is packed on right. Output It is used to create all kinds of menus used by the application. Syntax: window.w = Menu(master, option=value) Example: This code creates a menu bar containing "File" and "Help" menus. The Menu widget is used to build dropdown menus. Under "File", options like New, Open, a separator and Exit (which closes the app) are added. The "Help" menu contains an About option. The root.config(menu=menu) line links the menu bar to main window. Output: The Combobox widget from tkinter.ttk is created using Combobox class. Its options are set via values parameter, and a default value is assigned using set() method. An event handler (like on_select) can be bound using bind() to update other widgets based on selected item. Syntax: combo = Combobox(master, values=[...], state='readonly') Example: This program creates a dropdown menu using ttk.Combobox. It sets a default option and updates a label to show the selected item when a user makes a choice. Output:  It is used to provide a graphical slider that allows to select any value from that scale. Syntax: w = Scale(master, option=value) Example: This demonstrates how to create vertical and horizontal sliders using Scale widget. The first scale ranges from 0 to 42 (vertical by default) and second ranges from 0 to 200 with horizontal orientation. Output: This widget is directly controlled by the window manager. It don't need any parent window to work on. Syntax: w = TopLevel(master, option=value) Example: This code demonstrates use of Toplevel to create a new, separate window in addition to main application window. The main window is titled 'GfG' and secondary window titled 'Python' opens using Toplevel(), allowing for multi-window interfaces. Output It is a widget to display text messages with word wrapping. Syntax: w = Message(master, option=value) Example: This code demonstrates Message widget to display multi-line text. It creates a main window and shows a message with a light green background using Message widget, which automatically formats text to fit within window. Output It is a part of top-down menu which stays on the window all the time. Every menubutton has its own functionality. Syntax: w = MenuButton(master, option=value) Example: This code use Menubutton widget in Tkinter. It creates a button labeled "GfG" that displays a dropdown menu when clicked. The dropdown contains checkbutton options like "Contact" and "About", each linked to an IntVar to store their state (checked or unchecked). Output: progressbar indicates the progress of a long-running task. When the button is clicked, the progressbar fills up to 100% over a short period, simulating a task that takes time to complete. Syntax: Progressbar(parent, orient, length, mode) Example: This code create and control a Progressbar using Tkinter. It builds a GUI with a button that, when clicked, simulates a long-running task by gradually filling progress bar from 0 to 100%. The Progressbar is created using ttk.Progressbar and its value is updated inside a loop using time.sleep() to mimic delay, with update_idletasks() keeping UI responsive during operation. Output:  It is an entry of 'Entry' widget. Here, value can be input by selecting a fixed value of numbers. Syntax: w = SpinBox(master, option=value) Example: This code creates a simple Spinbox widget. The Spinbox allows users to select a numeric value from 0 to 10 using up/down arrows. The widget is packed into the main window using pack(). Output: To edit a multi-line text and format the way it has to be displayed. Syntax: w  =Text(master, option=value) Example: In this code text widget is used for multi-line text input or display. It is set to a height of 2 lines and a width of 30 characters. Some default text ('GeeksforGeeks\nBEST WEBSITE\n') is inserted using insert() Output: It is used to draw pictures and other complex layout like graphics, text and widgets. Syntax: w = Canvas(master, option=value) Example: This code creates a Canvas widget to draw a horizontal line. A canvas of width 40 and height 60 is created and a horizontal line is drawn across middle using create_line(). The canvas allows for drawing shapes like lines, rectangles and more. Output: It is a container widget which is used to handle number of panes arranged in it. Syntax: w = PannedWindow(master, option=value) Example: This code use PanedWindow widget which allows organizing child widgets in resizable panes. It creates a horizontal m1 and adds an Entry widget to its left. Then, a vertical m2 is nested inside m1, containing a Scale widget. Users can adjust the panes' size by dragging handles. Output This example demonstrates the usage of various color options in Tkinter widgets, including active background and foreground colors, background and foreground colors, disabled state colors and selection colors. Each widget in the example showcases a different color option, providing a visual representation of how these options affect the appearance of the widgets. Output  Learn more to Improve Font: Tkinter Font Tkinter also offers access to the geometric configuration of the widgets which can organize the widgets in the parent windows. There are mainly three geometry manager classes class. It organizes the widgets in blocks before placing in the parent widget. Widgets can be packed from the top, bottom, left or right. It can expand widgets to fill the available space or place them in a fixed size. Example: Output  It organizes the widgets in grid (table-like structure) before placing in the parent widget. Each widget is assigned a row and column. Widgets can span multiple rows or columns using rowspan and columnspan. Example: Output  It organizes the widgets by placing them on specific positions directed by the programmer. Widgets are placed at specific x and y coordinates. Sizes and positions can be specified in absolute or relative terms. Output  In Tkinter, events are actions that occur when a user interacts with the GUI, such as pressing a key, clicking a mouse button or resizing a window. Event handling allows us to define how our application should respond to these interactions. Events in Tkinter are captured and managed using a mechanism called bindings. A binding links an event to a callback function (also known as an event handler) that is called when the event occurs. Syntax: widget.bind(event, handler) Key events are triggered when a user presses a key on the keyboard. Mouse events are triggered by mouse actions, such as clicking or moving the mouse. Example: Output: Mouse moved to (182, 41) Mouse moved to (141, 20) Mouse moved to (134, 17) Mouse moved to (128, 15) Mouse moved to (125, 13) Mouse moved to (122, 12) Mouse moved to (120, 12) Mouse moved to (119, 12) Mouse moved to (117, 14) Mouse moved to (117, 18) In this advanced example, multiple event types are handled simultaneously. The on_mouse_motion function is called whenever the mouse is moved within the window, demonstrating how we can track and respond to continuous events. The event object is passed to the callback function when an event occurs. It contains useful information about the event, such as:
======================================================================

Link text: Data Structures Tutorial - GeeksforGeeks
URL: https://www.geeksforgeeks.org/data-structures/
Article headline: DSA Tutorial - Learn Data Structures and Algorithms
Last updated: 25 Sep, 2025
Description: DSA stands for D ata S tructures and A lgorithms. Data structures manage how data is stored and accessed. Algorithms focus on processing this data.  Examples of data structures are Array, Linked List, Tree and Heap, and examples of algorithms are Binary Search, Quick Sort and Merge Sort. Try our free courses GfG 160 and DSA Skillup with daily topic coverage, notes, quizzes and most asked coding problems. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory , allowing for constant-time access . Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order , such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. I n Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. I n Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. I n Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. A sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). A programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. A two-dimensional array of elements, arranged in rows and columns . It is represented as a rectangular grid, with each element at the intersection of a row and column. A linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially , starting from the head of list. A linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A Deque or double-ended queue is a data structure that allows elements to be added or removed from both ends efficiently. A non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems , databases , decision-making algorithms , etc. A complete binary tree that satisfies the heap property . Heaps are usually used to implement priority queues , where the smallest or largest element is always at the root of the tree. A non-linear data structure consisting of a finite set of vertices (or nodes) and a set of edges (or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems . By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Advanced Data Structures like Trie , Segment Tree , Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer: A strategy to solve problems by dividing them into smaller subproblems , solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable.
======================================================================

Link text: Python Projects for Beginner to Advanced - GeeksforGeeks
URL: https://www.geeksforgeeks.org/python-projects-beginner-to-advanced/
Article headline: Python Projects - Beginner to Advanced
Last updated: 19 Aug, 2025
Description: Here’s a list of Python projects from beginner to advanced levels, complete with key concepts and ideas to enhance your coding journey. After mastering Python programming language , practicing Python projects is a great way for beginners to practice and apply their coding skills in real-world scenarios. Here in this section, we have listed more than 20 beginner Python projects that help you to upscale your Python coding skills. Take your Python skills further with intermediate projects like creating bots for Twitter, WhatsApp, and Telegram, or building tools like an auto-login bot and an auto clicker. Explore data analysis with a Twitter Sentiment Analyzer, develop an Employee Management System, or make a file-sharing app. These projects help you learn more advanced Python skills while working on practical applications. Web scraping with Python allows you to extract valuable information from websites and automate data collection tasks. You can build projects like a COVID-19 Vaccine Tracker, an Email ID Extractor, or scrape weather data to send email reminders. These projects help you master web scraping tools and techniques, such as Scrapy, OpenCV, and other Python libraries. Python is a powerful tool for automating repetitive tasks, making your daily routine more efficient. So, in this section you we have listed more then 15 projects based on "Automation of Boring Stuff": Tkinter is a powerful library in Python for creating desktop applications with graphical user interfaces. With Tkinter, you can build a variety of projects like a calculator, a to-do list app, or even a text editor. These projects help beginners and intermediates learn the basics of GUI development, event handling, and creating user-friendly interfaces, providing a solid foundation for more advanced Python applications. Turtle graphics in Python offer a fun way to learn programming by drawing shapes and patterns. Here in this section we have listed various projects that will helps beginners as well as professionals to learn how to Python Turtle. Once you have completed the above projects. Django projects will help you understand web development concepts, manage databases, and create dynamic, full-featured websites with ease. In this section, we have listed projects on converting text to speech and speech to text using Python libraries like gTTS and SpeechRecognition. These projects are great for learning how to create applications that read text aloud or transcribe spoken words.
======================================================================

Link text: How To Access WhatsApp Web Without Phone
URL: https://www.geeksforgeeks.org/whatsapp-web-access-without-phone/
Article headline: No headline found
Last updated: Not found
Description: 
======================================================================

Link text: Python Dictionaries (with Examples)
URL: https://www.geeksforgeeks.org/python-dictionary/
Article headline: Python Dictionary
Last updated: 20 Sep, 2025
Description: Python dictionary is a data structure that stores the value in key: value pairs. Values in a dictionary can be of any data type and can be duplicated, whereas keys can't be repeated and must be immutable. Dictionary can be created by placing a sequence of elements within curly {} braces, separated by a 'comma'. We can access a value from a dictionary by using the key within square brackets or g et() method. We can add new key-value pairs or update existing keys by using assignment. We can remove items from dictionary using the following methods: We can iterate over keys [using keys() method ] , values [using values() method ] or both [using item() method ] with a for loop . Read in detail: Ways to Iterating Over a Dictionary  Example of Nested Dictionary: Read in Detail: Python Nested Dictionary
======================================================================

Link text: How to Read from a File in Python - GeeksforGeeks
URL: https://www.geeksforgeeks.org/how-to-read-from-a-file-in-python/
Article headline: Reading a File in Python
Last updated: 05 Sep, 2025
Description: Reading from a file in Python means accessing and retrieving contents of a file, whether it be text, binary data or formats like CSV and JSON. It is widely used in real-world applications such as reading configuration files, processing logs or handling datasets in data science. Example File: geeks.txt Hello World Hello GeeksforGeeks Basic file reading involves opening a file, reading its contents, and closing it properly to free up system resources. Steps: Example: This code opens a file, reads all its contents at once, prints them and then closes the file. Output: Hello World Hello GeeksforGeeks Explanation: This code opens geeks.txt in read mode, reads all its content into a string, prints it and then closes the file to free resources. Instead of manually closing files, we can use the with statement. It ensures the file is automatically closed when the block ends. Example: This code opens the file, reads its contents and automatically closes it after use. Output: Hello World Hello GeeksforGeeks Explanation: With with open(...), the file is closed automatically, preventing resource leaks. We may want to read a file line by line , especially for large files where reading the entire content at once is not practical. It is done with following two methods: Example 1: Using a Loop to Read Line by Line This code reads each line one by one and removes extra newline characters. Output: Hello World Hello GeeksforGeeks Explanation: This method reads each line of the file one at a time and prints it after removing leading/trailing whitespace. Example 2: Using readline() The readline() method reads one line at a time. We can keep calling it inside a loop until no lines are left. Output: Hello World Hello GeeksforGeeks Explanation: This method reads one line at a time, making it useful for processing very large files where loading entire content into memory at once is not efficient. Binary files store data in a format not meant to be read as text. These can include images, executables or any non-text data. We are using following methods to read binary files : open("example.bin", "rb"): Opens the file example.bin in read binary mode. Example: Reading a Binary File This code reads an entire binary file and prints its raw byte content. Output: b'Hello World\r\nHello GeeksforGeeks' Explanation: This code reads a file in binary mode ("rb") and prints its content as bytes, which is necessary for handling non-text files. Sometimes, we may only need to read a specific part of a file, such as the first few bytes, a specific line, or a range of lines. Example: This code reads only the first 10 characters of the file. Output: Hello Worl Explanation: Reading a limited number of characters is useful for quickly previewing content without loading the whole file. CSV (Comma-Separated Values) is widely used for storing tabular data. Python’s csv module helps parse CSV easily. Here, instead of needing an external file, we’ll simulate one using io.StringIO. Example : This code creates an in-memory CSV string, then reads it row by row. Output: ['Year', 'Industry', 'Value'] ['2014', 'Manufacturing', '769400'] ['2014', 'Manufacturing', '48000'] ['2014', 'Manufacturing', '12'] Explanation: Instead of a physical file, we used StringIO to create a file-like object. The CSV reader parses each line into a list of values. Reading JSON (JavaScript Object Notation) files are widely used in APIs and web applications for data transfer. Python's json module allows us to easily load JSON into dictionaries for further processing. Example: This code opens a JSON file, loads its data, and prints it as a Python dictionary. Output: {'fruit': 'Apple', 'size': 'Large', 'color': 'Red'} Explanation: The JSON file content is converted into a Python dictionary, which can be used directly in programs.
======================================================================

Link text: SQL Joins (Inner, Left, Right and Full Join)
URL: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/
Article headline: SQL Joins (Inner, Left, Right and Full Join)
Last updated: 18 Sep, 2025
Description: SQL joins are fundamental tools for combining data from multiple tables in relational databases. Let us visualize how each join type operates: The INNER JOIN keyword sele c ts all rows from both the tables as long as the condition is satisfied. This keyword will create the result set by combining all rows from both the tables where the condition satisfies i.e value of the common field will be the same. Syntax: Note : We can also write JOIN instead of INNER JOIN.  JOIN is same as INNER JOIN. Consider the two tables, Student and StudentCourse, which share a common column ROLL_NO . Using SQL JOINS, we can combine data from these tables based on their relationship, allowing us to retrieve meaningful information like student details along with their enrolled courses. ROLL_NO NAME ADDRESS PHONE AGE HARSH DELHI XXXXXXXXXX PRATIK BIHAR XXXXXXXXXX RIYANKA SILIGURI XXXXXXXXXX DEEP RAMNAGAR XXXXXXXXXX COURSE_ID ROLL_NO Let's look at the example of INNER JOIN clause, and understand it's working. This query will show the names and age of students enrolled in different courses. Query: Output: COURSE_ID NAME AGE HARSH PRATIK RIYANKA DEEP A LEFT JOIN returns all rows from the left table, along with matching rows from the right table. If there is no match, NULL values are returned for columns from the right table. LEFT JOIN is also known as LEFT OUTER JOIN. Syntax Note : We can also use LEFT OUTER JOIN instead of LEFT JOIN, both are the same. In this example, the LEFT JOIN retrieves all rows from the Student table and the matching rows from the StudentCourse table based on the ROLL_NO column. Query: Output: NAME COURSE_ID HARSH PRATIK RIYANKA DEEP RIGHT JOIN returns all the rows of the table on the right side of the join and matching rows for the table on the left side of the join. It is very similar to LEFT JOIN for the rows for which there is no matching row on the left side, the result-set will contain null. RIGHT JOIN is also known as RIGHT OUTER JOIN. Syntax Key Terms Note : We can also use RIGHT OUTER JOIN instead of RIGHT JOIN, both are the same In this example, the RIGHT JOIN retrieves all rows from the StudentCourse table and the matching rows from the Student table based on the ROLL_NO column. Query: Output: NAME COURSE_ID HARSH PRATIK RIYANKA DEEP NULL FULL JOIN creates the result-set by combining results of both LEFT JOIN and RIGHT JOIN. The result-set will contain all the rows from both tables. For the rows for which there is no matching, the result-set will contain NULL values. Syntax Key Terms This example demonstrates the use of a FULL JOIN, which combines the results of both LEFT JOIN and RIGHT JOIN. The query retrieves all rows from the Student and StudentCourse tables. If a record in one table does not have a matching record in the other table, the result set will include that record with NULL values for the missing fields Query: Output : NAME COURSE_ID HARSH PRATIK RIYANKA DEEP A Natural Join is a type of INNER JOIN that automatically joins two tables based on columns with the same name and data type. It returns only the rows where the values in the common columns match. Look at the two tables below: Employee and Department Employee Department Output:
======================================================================

Link text: Introduction of ER Model - GeeksforGeeks
URL: https://www.geeksforgeeks.org/introduction-of-er-model/
Article headline: Introduction of ER Model
Last updated: 09 Sep, 2025
Description: The Entity-Relationship Model (ER Model) is a conceptual model for designing a databases. This model represents the logical structure of a database, including entities, their attributes and relationships between them. The graphical representation of this model is called an Entity-Relation Diagram (ERD) . We typically follow the below steps for designing a database for an application. ER Model is used to model the logical view of the system from a data perspective which consists of these symbols: An Entity represents a real-world object, concept or thing about which data is stored in a database. It act as a building block of a database. Tables in relational database represent these entities. Example of entities: The entity type defines the structure of an entity, while individual instances of that type represent specific entities. An entity refers to an individual object of an entity type, and the collection of all entities of a particular type is called an entity set. For example, E1 is an entity that belongs to the entity type "Student," and the group of all students forms the entity set. In the ER diagram below, the entity type is represented as: We can represent the entity sets in an ER Diagram but we can't represent individual entities because an entity is like a row in a table, and an ER diagram shows the structure and relationships of data, not specific data entries (like rows and columns). An ER diagram is a visual representation of the data model, not the actual data itself. There are two main types of entities: A Strong Entity is a type of entity that has a key Attribute that can uniquely identify each instance of the entity. A Strong Entity does not depend on any other Entity in the Schema for its identification. It has a primary key that ensures its uniqueness and is represented by a rectangle in an ER diagram. A Weak Entity cannot be uniquely identified by its own attributes alone. It depends on a strong entity to be identified. A weak entity is associated with an identifying entity (strong entity), which helps in its identification. A weak entity are represented by a double rectangle. The participation of weak entity types is always total. The relationship between the weak entity type and its identifying strong entity type is called identifying relationship and it is represented by a double diamond. Example: A company may store the information of dependents (Parents, Children, Spouse) of an Employee. But the dependents can't exist without the employee. So dependent will be a  Weak Entity Type  and Employee will be identifying entity type for dependent, which means it is  Strong Entity Type. Attributes are the properties that define the entity type. For example, for a Student entity Roll_No, Name, DOB, Age, Address, and Mobile_No are the attributes that define entity type Student. In ER diagram, the attribute is represented by an oval. The attribute which uniquely identifies each entity  in the entity set is called the key attribute. For example, Roll_No will be unique for each student. In ER diagram, the key attribute is represented by an oval with an underline. An attribute composed of many other attributes is called a composite attribute. For example, the Address attribute of the student Entity type consists of Street, City, State, and Country. In ER diagram, the composite attribute is represented by an oval comprising of ovals. An attribute consisting of more than one value for a given entity. For example, Phone_No (can be more than one for a given student). In ER diagram, a multivalued attribute is represented by a double oval. An attribute that can be derived from other attributes of the entity type is known as a derived attribute. e.g.; Age (can be derived from DOB). In ER diagram, the derived attribute is represented by a dashed oval. The Complete Entity Type Student with its Attributes can be represented as: A Relationship Type represents the association between entity types. For example, ‘Enrolled in’ is a relationship type that exists between entity type Student and Course. In ER diagram, the relationship type is represented by a diamond and connecting the entities with lines. A set of relationships of the same type is known as a relationship set. The following relationship set depicts S1 as enrolled in C2, S2 as enrolled in C1, and S3 as registered in C3. The number of different entity sets participating in a relationship set is called the degree of a relationship set. 1. Unary/Recursive Relationship: When there is only ONE entity set participating in a relation, the relationship is called a unary relationship. For example, one person is married to only one person. Read more about - Recursive Relationship 2. Binary Relationship: When there are TWO entities set participating in a relationship, the relationship is called a binary relationship. For example, a Student is enrolled in a Course. 3. Ternary Relationship: When there are three entity sets participating in a relationship, the relationship is called a ternary relationship. 4. N-ary Relationship: When there are n entities set participating in a relationship, the relationship is called an n-ary relationship. The maximum number of times an entity of an entity set participates in a relationship set is known as cardinality . Cardinality can be of different types: When each entity in each entity set can take part only once in the relationship, the cardinality is one-to-one. Let us assume that a male can marry one female and a female can marry one male. So the relationship will be one-to-one. Using Sets, it can be represented as: In one-to-many mapping as well where each entity can be related to more than one entity. Let us assume that one surgeon department can accommodate many doctors. So the Cardinality will be 1 to M. It means one department has many Doctors. Using sets, one-to-many cardinality can be represented as: When entities in one entity set can take part only once in the relationship set and entities in other entity sets can take part more than once in the relationship set, cardinality is many to one. Let us assume that a student can take only one course but one course can be taken by many students. So the cardinality will be n to 1. It means that for one course there can be n students but for one student, there will be only one course. Using Sets, it can be represented as: In this case, each student is taking only 1 course but 1 course has been taken by many students. When entities in all entity sets can take part more than once in the relationship cardinality is many to many. Let us assume that a student can take more than one course and one course can be taken by many students. So the relationship will be many to many. Using Sets, it can be represented as: In this example, student S1 is enrolled in C1 and C3 and Course C3 is enrolled by S1, S3, and S4. So it is many-to-many relationships. Participation Constraint is applied to the entity participating in the relationship set. 1. Total Participation: Each entity in the entity set  must participate in the relationship. If each student must enroll in a course, the participation of students will be total. Total participation is shown by a double line in the ER diagram. 2. Partial Participation: The entity in the entity set may or may NOT participate in the relationship. If some courses are not enrolled by any of the students, the participation in the course will be partial. The diagram depicts the ‘Enrolled in’ relationship set with Student Entity set having total participation and Course Entity set having partial participation. Using Set, it can be represented as, Every student in the Student Entity set participates in a relationship but there exists a course C4 that is not taking part in the relationship. 1. Identify Entities: The very first step is to identify all the Entities. Represent these entities in a Rectangle and label them accordingly. 2. Identify Relationships : The next step is to identify the relationship between them and represent them accordingly using the Diamond shape. Ensure that relationships are not directly connected to each other. 3. Add Attributes : Attach attributes to the entities by using ovals. Each entity can have multiple attributes (such as name, age, etc.), which are connected to the respective entity. 4. Define Primary Keys: Assign primary keys to each entity. These are unique identifiers that help distinguish each instance of the entity. Represent them with underlined attributes. 5. Remove Redundancies : Review the diagram and eliminate unnecessary or repetitive entities and relationships. 6. Review for Clarity : Review the diagram make sure it is clear and effectively conveys the relationships between the entities.
======================================================================

Link text: Python Match Case Statement - GeeksforGeeks
URL: https://www.geeksforgeeks.org/python-match-case-statement/
Article headline: Python Match Case Statement
Last updated: 15 Sep, 2025
Description: Introduced in Python 3.10, the match case statement offers a powerful mechanism for pattern matching in Python . It allows us to perform more expressive and readable conditional checks. Unlike traditional if-elif-else chains, which can become unwieldy with complex conditions, the match-case statement provides a more elegant and flexible solution. Explanation: Let's take a look at python match case statement in detail: The match-case syntax is based on structural pattern matching, which enables matching against data structures like sequences, mappings and even classes, providing more granularity and flexibility in handling various conditions. This feature is particularly useful when dealing with different types of data in a clear and organized manner. match subject: case pattern1: # Code block if pattern1 matches case pattern2: # Code block if pattern2 matches case _: # Default case (wildcard) if no other pattern matches Now, let us see a few examples to know how the match case statement works in Python. The power of the match-case statement lies in its ability to match a variety of data types, including constants, sequences, mappings and custom classes. Let's explore how to use match-case with different data types. Matching constants is one of the simplest uses of the match-case statement. It checks if a variable matches specific constant values and allows for different actions based on the matched constant. Explanation: The match-case statement can also be used with logical operators like or to combine multiple patterns. This allows for a more flexible matching system where you can group patterns and check for a match against any of them. Example: Explanation: We can also add an if condition after a case to create more granular control over the matching process. This allows us to add additional checks within a case. Example: Explanation: The match-case statement is particularly powerful when working with sequences such as lists or tuples . We can match individual elements of a sequence or even match the structure of the sequence itself. Example: Explanation: A mapping is another common data type in Python and match-case can be used to match against dictionaries , checking for specific keys and values. Explanation: One of the most powerful features of match-case is the ability to match against classes . We can match instances of a class and even extract specific attributes of an object for further handling. Example: Explanation:
======================================================================

Link text: Depth First Search or DFS for a Graph - GeeksforGeeks
URL: https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/
Article headline: Depth First Search or DFS for a Graph
Last updated: 03 Oct, 2025
Description: In Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to a depth first tree traversal , where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a boolean visited array. Example: Note : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Input: adj =  [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]] Output: [ 0 1 2 3 4] Explanation: The source vertex s is 0. We visit it first, then we visit an adjacent. Start at 0: Mark as visited. Output: 0 Move to 1: Mark as visited. Output: 1 Move to 2: Mark as visited. Output: 2 Move to 3: Mark as visited. Output: 3 (backtrack to 2) Move to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 1, then to 0) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Input: [[2,3,1], [0], [0,4], [0], [2]] Output: [0 2 4 3 1] Explanation: DFS Steps: Start at 0: Mark as visited. Output: 0 Move to 2: Mark as visited. Output: 2 Move to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0) Move to 3: Mark as visited. Output: 3 (backtrack to 0) Move to 1: Mark as visited. Output: 1 (backtrack to 0) The algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to Preorder Tree Traversal where we visit the root, then recur for its children. In a graph, there might be loops. So we use an extra visited array to make sure that we do not process a vertex again. Let us understand the working of Depth First Search with the help of the following Illustration: for the source as 0 .  Time complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph. Auxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to dfsRec function. Please refer Complexity Analysis of Depth First Search for details. The above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us now talk about the algorithm that prints all vertices without any source and the graph maybe disconnected. The idea is simple, instead of calling DFS for a single vertex, we call the above implemented DFS for all all non-visited vertices one by one. Time complexity: O(V + E). Note that the time complexity is same here because we visit every vertex at most once and every edge is traversed at most once (in directed) and twice in undirected. Auxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to dfsRec function.
======================================================================

Link text: Dynamic Memory Allocation in C using malloc(), calloc(), free() and realloc() - GeeksforGeeks
URL: https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/
Article headline: Dynamic Memory Allocation in C
Last updated: 23 Sep, 2025
Description: Dynamic memory allocation techniques give programmer control of memory when to allocate, how much to allocate and when to de-allocate. Dynamic memory allocation is possible in C by using the following 4 library functions provided by <stdlib.h> library: The malloc() (stands for m emory alloc ation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values. Assume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown: In the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store. Moreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL. where size is the number of bytes to allocate. This function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer. The calloc() (stands for c ontiguous alloc ation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values. where n is the number of elements and size is the size of each element in bytes. This function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer. The memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks. After calling free(), it is a good practice to set the pointer to NULL to avoid using a "dangling pointer," which points to a memory location that has been deallocated. where ptr is the pointer to the allocated memory. After freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location. realloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block. Suppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block: It is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until you've successfully allocated a new block. To prevent memory leaks, it’s a good practice to handle the NULL return value carefully: Consider the first scenario where we were having issues with the fixes size array. Let's see how we can resolve both of these issues using dynamic memory allocation. In this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays . As useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below: The functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions. It turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.
======================================================================

Link text: Sorting Algorithms - GeeksforGeeks
URL: https://www.geeksforgeeks.org/sorting-algorithms/
Article headline: Sorting Algorithms
Last updated: 24 Aug, 2025
Description: A Sorting Algorithm is used to rearrange a given array or list of elements in an order.  For example, a given array [10, 20, 5, 2] becomes [2, 5, 10, 20] after sorting in increasing order and becomes [20, 10, 5, 2] after sorting in decreasing order. Comparison Based : Selection Sort , Bubble Sort , Insertion Sort , Merge Sort , Quick Sort , Heap Sort , Cycle Sort , 3-way Merge Sort Non Comparison Based : Counting Sort , Radix Sort , Bucket Sort , TimSort , Comb Sort , Pigeonhole Sort Hybrid Sorting Algorithms : IntroSort , Tim Sort Quick Links :
======================================================================

Link text: grep command in Unix/Linux - GeeksforGeeks
URL: https://www.geeksforgeeks.org/grep-command-in-unixlinux/
Article headline: grep command in Unix/Linux
Last updated: 01 Jul, 2025
Description: The grep command is one of the most useful tools in Linux and Unix systems. It is used to search for specific words, phrases, or patterns inside text files, and shows the matching lines on your screen. The basic syntax of the ` grep` command is as follows: grep Command is useful when you need to quickly find certain keywords or phrases in logs or documents. If you have a file called notes.txt and you want to find all lines containing the word Python, you can use: Here's the output: If you want to search for the word error in all files under the /var/log directory, you can run: Note: If you are not logged in as the root user, you may need to use sudo to access protected log files, like this: Here, -r tells grep to search recursively , meaning it will look inside all subfolders too. Its name comes from an old editor command: g/re/p , which stands for “globally search for a regular expression and print. Here are some use cases of grep command: The -i option enables to search for a string case insensitively in the given file. It matches the words like "UNIX", "Unix", "unix". Output: We can find the number of lines that matches the given string/pattern Output: We can just display the files that contains the given string/pattern. or Output: By default, grep matches the given string/pattern even if it is found as a substring in a file. The -w option to grep makes it match only the whole words. Output: By default, grep displays the entire line which has the matched string. We can make the grep to display only the matched string by using the -o option. Output: To show the line number of file with the line matched. Output: You can display the lines that are not matched with the specified search string pattern using the -v option. Output: The ^ regular expression pattern specifies the start of a line. This can be used in grep to match the lines which start with the given string or pattern. Output: The $ regular expression pattern specifies the end of a line. This can be used in grep to match the lines which end with the given string or pattern. Can use multiple times : It is used to search for multiple patterns, listed in a separate file, within another target file. Agarwal Aggarwal Agrawal -A prints the searched line and n lines after the result, -B prints the searched line and n lines before the result, and -C prints the searched line and n lines after and before the result. Syntax: Example: Output: In this article we discussed the grep command in Linux which is a powerful text-search tool that uses regular expressions to find patterns or text within files. It offers various options like case insensitivity, counting matches, and listing file names. With the ability to search recursively, use regular expression flags, and customize output, grep is a vital tool for Linux users to efficiently handle text-related tasks. Mastering grep enhances your ability to work with text data in the Linux environment.
======================================================================

Link text: Linux Commands Cheat Sheet: Beginner to Advanced 2025
URL: https://www.geeksforgeeks.org/linux-commands-cheat-sheet/
Article headline: Linux Commands Cheat Sheet
Last updated: 23 Jul, 2025
Description: Linux, often associated with being a complex operating system primarily used by developers, may not necessarily fit that description entirely. While it can initially appear challenging for beginners, once you immerse yourself in the Linux world, you may find it difficult to return to your previous Windows systems. The power of Linux commands in controlling your PC, coupled with their clean user interface, can make it hard to switch back to older operating systems. If you're a developer, you can likely relate to the advantages and appeal of Linux. To support developers and beginners alike, we have created a comprehensive Linux/Unix command line cheat sheet . This cheat sheet covers all the basic and advanced commands, including file and directory commands, file permission commands, file compression and archiving, process management, system information, networking, and more with proper examples and descriptions. In addition to that we provide all the most used Linux Shortcut which includes Bash shortcuts, Nano shortcuts, VI & Vim Shortcuts Commands. It provides a solid foundation on Linux OS commands, as well as insights into practical applications. By the end of this cheat sheet, you will have a basic understanding of Linux/Unix Commands and how it makes development easy for developers. What is Linux? Linux is an open-source UNIX-like operating system (OS). An operating system is a software that directly manages a system’s hardware and resources, like CPU, memory, and storage. OS acts as a GUI through which user can communicate with the computer. The OS sits between applications and hardware and makes the connections between all of your software and the physical resources that do the work. In this Linux cheat sheet, we will cover all the most important Linux commands, from the basics to the advanced. We will also provide some tips on how to practice and learn Linux commands. This cheat sheet is useful for Beginners and Experience professionals. File and directory operations are fundamental in working with the Linux operating system. Here are some commonly used File and Directory Operations commands: Command Description Options Examples File permissions on Linux and Unix systems control access to files and directories. There are three basic permissions: read, write, and execute. Each permission can be granted or denied to three different categories of users: the owner of the file, the members of the file's group, and everyone else. Here are some file permission commands: Command Description Options Examples Here are some file compression and archiving commands in Linux: Commands Description Options Examples In Linux, process management commands allow you to monitor and control running processes on the system. Here are some commonly used process management commands: Commands Description Options Examples In Linux, there are several commands available to gather system information. Here are some commonly used system information commands: sudCommand Description Options Examples In Linux, there are several networking commands available to manage and troubleshoot network connections. Here are some commonly used networking commands: Command Description Examples In Linux, IO (Input/Output) redirection commands are used to redirect the standard input, output, and error streams of commands and processes. Here are some commonly used IO redirection commands: Command Description In Linux, environment variables are used to store configuration settings, system information, and other variables that can be accessed by processes and shell scripts. Here are some commonly used environment variable commands: Command Description In Linux, user management commands allow you to create, modify, and manage user accounts on the system. Here are some commonly used user management commands: Command Description There are many shortcuts commands in Linux that can help you be more productive. Here are a few of the most common ones: :wq or :set nu or :set number In conclusion, Linux is a widely used operating system for development, and as a developer, you should have knowledge of Linux and its basic commands. In this Cheat Sheet, we covered all commands like creating directories, file compression and archiving, process management, system information, networking and more. In addition to that, this Linux Cheat Sheet is organized and categorized, making it easy for developers to quickly find the commands they need for specific use cases. By utilizing this resource, developers can enhance their productivity and efficiency in working with Linux, leading to smoother and more successful development projects.  
======================================================================

Link text: One Hot Encoding in Machine Learning - GeeksforGeeks
URL: https://www.geeksforgeeks.org/ml-one-hot-encoding/
Article headline: One Hot Encoding in Machine Learning
Last updated: 11 Jul, 2025
Description: One Hot Encoding is a method for converting categorical variables into a binary format. It creates new columns for each category where 1 means the category is present and 0 means it is not. The primary purpose of One Hot Encoding is to ensure that categorical data can be effectively used in machine learning models. We use one hot Encoding because: To grasp the concept better let's explore a simple example. Imagine we have a dataset with fruits their categorical values and corresponding prices. Using one-hot encoding we can transform these categorical values into numerical form. For example: The output after applying one-hot encoding on the data is given as follows, To implement one-hot encoding in Python we can use either the Pandas library or the Scikit-learn library both of which provide efficient and convenient methods for this task. Pandas offers the get_dummies function which is a simple and effective way to perform one-hot encoding. This method converts categorical variables into multiple binary columns . Output: We can observe that we have 3 Remarks and 2 Gender columns in the data. However you can just use n-1 columns to define parameters if it has n unique labels. For example if we only keep the Gender_Female column and drop the Gender_Male column then also we can convey the entire information as when the label is 1 it means female and when the label is 0 it means male. This way we can encode the categorical data and reduce the number of parameters as well. Scikit-learn(sklearn) is a popular machine-learning library in Python that provide numerous tools for data preprocessing. It provides a OneHotEncoder function that we use for encoding categorical and numerical variables into binary vectors. Using df.select_dtypes(include=['object']) in Scikit Learn Library: Output: Both Pandas and Scikit-Learn offer robust solutions for one-hot encoding. To make the most of One Hot Encoding and we must consider the following best practices: While One Hot Encoding is a popular choice for handling categorical data there are several alternatives that may be more suitable depending on the context:
======================================================================

Link text: C++ Programming Language - GeeksforGeeks
URL: https://www.geeksforgeeks.org/c-plus-plus/
Article headline: C++ Programming Language
Last updated: 22 Sep, 2025
Description: C++ is a programming language known for its fast speed, low level memory management and is often taught as first programming language. The below code shows the simplest C++ program that you can run to print some text on the console screen. This section guides you through the basic concepts of C++ programming. It covers topics that teaches you to write your first program, manage data, perform different operations and control the flow of the program. Functions allow users to divide the program into multiple blocks each performing a specific task. This section teaches you how to work with functions to write a modular and reusable code. Compound data types are created from the built-in data types. This section guides you through important compound data types such as array, strings, pointer and structures that helps in managing complex real-world data. C++ allows the low-level memory manipulation using pointers and dynamic memory allocation/deallocation operators. This section guides you through the basis of dynamic memory management. This section covers key concepts of Object-Oriented Programming (OOP) in C++ such as classes, objects, encapsulation, inheritance, polymorphism, and abstraction. This section covers Standard Template Library (STL) which is an in-built library that provides a set of commonly used data structures such as vectors, lists, stacks, queues, maps, etc. and algorithms that enhance productivity and performance. Exception handling are the techniques to handle runtime errors efficiently. This section covers how to handle exceptions to prevent crashes and improve the reliability of applications. File handling allows programs to store and retrieve data from files. This section introduces file handling in C++ using streams. It covers reading from and writing to files using streams. This section covers advanced concepts in C++ such as move preprocessor, multithreading, etc. Mastering these topics allows developers to write efficient, high-performance C++ applications. Test what you have learnt through this C++ using a series of our Skill Assessment Test. Quickly prepare yourself for C++ interviews with the help of our carefully curated list of commonly asked interview questions.
======================================================================

Link text: Defaultdict in Python - GeeksforGeeks
URL: https://www.geeksforgeeks.org/defaultdict-in-python/
Article headline: Defaultdict in Python
Last updated: 04 Oct, 2025
Description: In Python, defaultdict is a subclass of the built-in dict class from the collections module. It automatically assigns a default value to keys that do not exist, which means you don’t have to manually check for missing keys and avoid KeyError. This example shows how a defaultdict automatically creates missing keys with a default empty list. Explanation: This code creates a defaultdict with a default value of an empty list. It adds elements to the 'fruits' and 'vegetables' keys. When trying to access the 'juices' key, no KeyError is raised, and an empty list is returned since it doesn't exist in the dictionary. defaultdict(default_factory) Parameters: Return Value: It returns a dictionary-like object that automatically supplies a default value for missing keys instead of raising KeyError. In a normal dictionary, accessing a missing key raises a KeyError. defaultdict solves this by: When you create a defaultdict, you specify a default_factory (a callable). For example: This mechanism avoids errors and makes code simpler when handling missing keys. When the list class is passed as the default_factory argument, then a defaultdict is created with the values that are list. Example: This example shows how we can use list as the default factory, so every missing key will automatically start with an empty list. Explanation: This example demonstrates the use of list as the default factory. A defaultdict is created with list, which means any missing key will automatically have an empty list as its value. The loop appends the value of i to the list of the corresponding key. When the int class is passed as the default_factory argument, then a defaultdict is created with default value as zero. Example: This example demonstrates using int as the default factory, making missing keys default to 0. Explanation: This example uses int as the default factory. int() returns 0 , so missing keys will have a default value of 0 . The loop counts the occurrences of each number in the list a and updates the dictionary accordingly. With defaultdict(str), any new key automatically maps to '', so you can concatenate text without key checks. Example: This example shows how str as a factory creates empty strings ("") for missing keys. Explanation: This example uses str as the default factory. str() returns an empty string, so missing keys will have an empty string as their default value. A value (' Hello ') is explicitly set for the key ' greeting '. defaultdict is very handy in text processing, for example grouping words by their starting letter. Example: This example demonstrates how defaultdict(list) can be used to group words by their first letter, very useful in text processing. Explanation: Here, defaultdict(list) automatically creates an empty list for each new first letter, so we can group words without checking if the key exists. Behind the scenes, defaultdict uses the special __missing__() method: Example: This example shows how the __missing__() method works behind the scenes in defaultdict. It is automatically called when a key is not found, returning the default value instead of raising a KeyError. Explanation: Note: __missing__() is intended for internal use in defaultdict. To safely access values, use d[key] or d.get(key, default) instead of calling __missing__ directly.
======================================================================

Link text: *args and **kwargs in Python - GeeksforGeeks
URL: https://www.geeksforgeeks.org/args-kwargs-python/
Article headline: *args and **kwargs in Python
Last updated: 20 Sep, 2025
Description: In Python, *args and **kwargs are used to allow functions to accept an arbitrary number of arguments. These features provide great flexibility when designing functions that need to handle a varying number of inputs. Below code shows how *args collects multiple positional arguments into a tuple and how **kwargs collects keyword arguments into a dictionary. Python provides two special symbols for passing variable numbers of arguments: Note: “We use the "wildcard" or "*" notation like this - *args OR **kwargs - as our function's argument when we have doubts about the number of  arguments we should pass in a function.” The special syntax *args allows us to pass any number of positional (non-keyword) arguments to a function. These arguments are collected into a tuple , which means we can loop through them or use them with built-in functions. This is useful when you don’t know in advance how many values will be passed. Below example shows how *args can collect multiple values and let us iterate through them. Explanation: Here we use *args to multiply any number of values. Explanation: The special syntax **kwargs allows us to pass any number of keyword arguments (arguments in the form key=value). These arguments are collected into a dictionary , where: This is useful when you want your function to accept flexible, named inputs. Below example shows how **kwargs stores arguments in a dictionary. Explanation: Here we use **kwargs to create a formatted string from the arguments. Explanation: We can also combine *args and **kwargs in the same function. This way, the function can accept both positional and keyword arguments at once. Explanation:
======================================================================

Link text: Arrays in Java - GeeksforGeeks
URL: https://www.geeksforgeeks.org/arrays-in-java/
Article headline: Arrays in Java
Last updated: 30 Sep, 2025
Description: In Java, an array is an important linear data structure that allows us to store multiple values of the same type. The general form of array declaration is // Method 1: int arr[]; // Method 2: int[] arr; The element type determines the data type of each element that comprises the array. Like an array of integers, we can also create an array of other primitive data types like char, float, double, etc. or user-defined data types (objects of a class). Note: It is just how we can create is an array variable, no actual array exists. It merely tells the compiler that this variable (int Array) will hold an array of the integer type. When an array is declared, only a reference of an array is created.  We use new to allocate an array of given size. int arr[] = new int[size]; Array Literal in Java In a situation where the size of the array and variables of the array are already known, array literals can be used. // Declaring array literal int[] arr = new int[]{ 1,2,3,4,5,6,7,8,9,10 }; To change an element, assign a new value to a specific index. The index begins with 0 and ends at (total array size)-1. // Changing the first element to 90 arr[0] = 90; We can get the length of an array using the length property: // Getting the length of the array int n = arr.length; Java program to illustrate creating an array of integers, puts some values in the array and prints each value to standard output An array of objects is created like an array of primitive-type data items Example : Here we are taking a student class and creating an array of Student with five Student objects stored in the array. The Student objects have to be instantiated using the constructor of the Student class and their references should be assigned to the array elements. JVM throws ArrayIndexOutOfBoundsException to indicate that the array has been accessed with an illegal index. The index is either negative or greater than or equal to the size of an array. Below code shows what happens if we try to access elements outside the array size: Output: Like variables, we can also pass arrays to methods. For example, the below program passes the array to method sum to calculate the sum of the array's values. Example: As usual, a method can also return an array. For example, the below program returns an array from method m1. Example:
======================================================================

Link text: Python Lists - GeeksforGeeks
URL: https://www.geeksforgeeks.org/python-lists/
Article headline: Python Lists
Last updated: 03 Oct, 2025
Description: In Python, a list is a built-in data structure that can hold an ordered collection of items. Unlike arrays in some languages, Python lists are very flexible: Lists can be created in several ways, such as using square brackets, the list() constructor or by repeating elements. Let's look at each method one by one with example: We use square brackets [] to create a list directly. We can also create a list by passing an iterable (like a tuple , string or another list) to the list() function. We can use the multiplication operator * to create a list with repeated items. Elements in a list are accessed using indexing. Python indexes start at 0, so a[0] gives the first element. Negative indexes allow access from the end (e.g., -1 gives the last element). We can add elements to a list using the following methods: Since lists are mutable, we can update elements by accessing them via their index. We can remove elements from a list using: We can iterate over lists using loops , which is useful for performing actions on each item. To learn various other methods, please refer to iterating over lists . A nested list is a list within another list, which is useful for representing matrices or tables. We can access nested elements by chaining indexes. To learn more, please refer to Multi-dimensional lists in Python List comprehension is a concise way to create lists using a single line of code. It is useful for applying an operation or filter to items in an iterable, such as a list or range. Explanation: In Python, a list doesn’t store actual values directly. Instead, it stores references (pointers) to objects in memory. This means numbers, strings and booleans are separate objects in memory and the list just keeps their addresses. That’s why modifying a mutable element (like another list or dictionary) can change the original object, while immutables remain unaffected. Explanation: Related Links: Recommended Problems:
======================================================================

Link text: Deque in Python - GeeksforGeeks
URL: https://www.geeksforgeeks.org/deque-in-python/
Article headline: Deque in Python
Last updated: 03 Sep, 2025
Description: A deque stands for Double-Ended Queue. It is a special type of data structure that allows you to add and remove elements from both ends efficiently. Unlike normal queues (which usually follow First In, First Out), a deque supports both FIFO and LIFO operations. This makes it very flexible and useful in real-world applications like task scheduling, sliding window problems and real-time data processing. Here’s a table listing built-in operations of a deque in Python with descriptions and their corresponding time complexities: Output:
======================================================================

Link text: Sed Command in Linux/Unix With Examples - GeeksforGeeks
URL: https://www.geeksforgeeks.org/sed-command-in-linux-unix-with-examples/
Article headline: Sed Command in Linux/Unix With Examples
Last updated: 15 Sep, 2025
Description: The sed command in Linux, short for stream editor, is a non-interactive text editor used to perform basic text transformations on an input stream, such as a file or input from a pipeline. It processes text line by line, applying the editing commands you specify. It can also Internally, sed works with two workspaces: the pattern space, which holds the line being modified, and the hold space, which can temporarily store a line for later use. The basic syntax for using the SED command in Linux is: where, Below are some of the most frequently used SED command options, let's check them out: Here are some basic SED commands that will help you get started with text manipulation. Consider the below text file as an input. Replacing or substituting string: Sed command is mostly used to replace the text in a file. The below simple sed command replaces the word "unix" with "linux" in the file. Output: Here the "s" specifies the substitution operation. The "/" are delimiters. The "unix" is the search pattern and the "linux" is the replacement string. By default, the sed command replaces the first occurrence of the pattern in each line and it won't replace the second, third...occurrence in the line. To replace only the nth occurance of a word in a line, use the following syntax: Use the '/1', '/2' etc. flags to replace the first, second occurrence of a pattern in a line. The below command replaces the second occurrence of the word "unix" with "linux" in a line. Output: Here, we will use the g flag to replace all the occurances of a pattern in a line. Let's check out the syntax below: The substitute flag /g (global replacement) specifies the sed command to replace all the occurrences of the string in the line. Output: Use the combination of /1, /2 etc and /g to replace all the patterns from the nth occurrence of a pattern in a line. The following sed command replaces the third, fourth, fifth... "unix" word with "linux" word in a line. Output: This sed example prints the first character of every word in parenthesis. Output: You can restrict the sed command to replace the string on a specific line number. An example is Output: The above sed command replaces the string only on the third line. The /p print flag prints the replaced line twice on the terminal. If a line does not have the search pattern and is not replaced, then the /p prints that line only once. Output: Use the -n option along with the /p print flag to display only the replaced lines. Here the -n option suppresses the duplicate rows generated by the /p flag and prints the replaced lines only one time. Output: If you use -n alone without /p, then the sed does not print anything. You can specify a range of line numbers to the sed command for replacing a string. Output: Here the sed command replaces the lines with range from 1 to 3. Another example is Output: Here $ indicates the last line in the file. So the sed command replaces the text from second line to last line in the file. SED command can also be used for deleting lines from a particular file. SED command is used for performing deletion operation without even opening the file Examples: For more: SED command in Linux | Set 2 Below are some of the advanced SED commands that can be used for handling various editing tasks. let's check them out: SED supports regular expressions that allows it to handle more complex pattern matching . To enable regular expressions , you need to use -r option. Example: Here, we have matched any word start with ' u' and replacing it with " Linux". Let's check this out in the provided syntax below: You can use this option to insert any text before or after any specific line. Here's the syntax provided below: Example: To insert a new line before line2 in geekfile.txt The SED command in Linux/Unix is a versatile and powerful and flexible tool for automating a wide range of text editing tasks. Whether you need to perform simple substitutions or complex pattern-based transformations, SED enables you to process files efficiently right from the command line. Its ability to edit files in-place, handle large-scale replacements, and work seamlessly within scripts makes it an essential utility for developers, system administrators, and anyone working with text processing in Unix like environements.
======================================================================

Link text: Top 100 SQL Interview Questions and Answers (2025)
URL: https://www.geeksforgeeks.org/sql-interview-questions/
Article headline: SQL Interview Questions - DBMS
Last updated: 09 Sep, 2025
Description: SQL is a standard database language used for accessing and manipulating data in databases. It stands for Structured Query Language and was developed by IBM in the 1970's, SQL allows us to create, read, update, and delete data with simple yet effective commands. For both newcomers and seasoned professionals, mastering SQL is a must-have skill in today’s data-driven job market SQL (Structured Query Language) is a standard programming language used to communicate with relational databases. It allows users to create, read, update, and delete data, and provides commands to define database schema and manage database security. A database is an organized collection of data stored electronically, typically structured in tables with rows and columns. It is managed by a database management system (DBMS), which allows for efficient storage, retrieval, and manipulation of data. SQL commands are broadly classified into: A primary key is a unique identifier for each record in a table. It ensures that no two rows have the same value in the primary key column(s), and it does not allow NULL values. A foreign key is a column (or set of columns) in one table that refers to the primary key in another table. It establishes and enforces a relationship between the two tables, ensuring data integrity. The DEFAULT constraint assigns a default value to a column when no value is provided during an INSERT operation. This helps maintain consistent data and simplifies data entry. Normalization is the process of organizing data in a database to reduce redundancy and improve data integrity. This involves dividing large tables into smaller, related tables and defining relationships between them to ensure consistency and avoid anomalies. Denormalization is the process of combining normalized tables into larger tables for performance reasons. It is used when complex queries and joins slow down data retrieval, and the performance benefits outweigh the drawbacks of redundancy. A query is a SQL statement used to retrieve, update, or manipulate data in a database. The most common type of query is a SELECT statement , which fetches data from one or more tables based on specified conditions. A view is a virtual table created by a SELECT query. It does not store data itself, but presents data from one or more tables in a structured way. Views simplify complex queries, improve readability, and enhance security by restricting access to specific rows or columns. Some views are updatable (if they meet certain conditions, like no GROUP BY or DISTINCT), allowing inserts/updates through them. The UNIQUE constraint ensures that all values in a column (or combination of columns) are distinct. This prevents duplicate values and helps maintain data integrity. The GROUP BY clause is used to arrange identical data into groups . It is typically used with aggregate functions (such as COUNT, SUM, AVG) to perform calculations on each group rather than on the entire dataset. Aggregate functions perform calculations on a set of values and return a single value. Common aggregate functions include: A subquery is a query nested within another query. It is often used in the WHERE clause to filter data based on the results of another query, making it easier to handle complex conditions. In short, WHERE applies to individual rows, while HAVING applies to groups Indexes are database objects that improve query performance by allowing faster retrieval of rows. They function like a book’s index, making it quicker to find specific data without scanning the entire table. However, indexes require additional storage and can slightly slow down data modification operations. Types of Indexes: TRUNCATE is a DDL command, while DELETE is a DML command, which is why they differ in speed and logging behavior. The ORDER BY clause sorts the result set of a query in either ascending (default) or descending order, based on one or more columns. This helps present the data in a more meaningful or readable sequence. SQL is best for structured, reliable transactions, while NoSQL shines in handling massive, fast-changing, and unstructured data. SQL Databases : NoSQL Databases: A table is a structured collection of related data organized into rows and columns. Columns define the type of data stored, while rows contain individual records. Common constraints include: A cursor is a database object used to retrieve, manipulate, and traverse through rows in a result set one row at a time. Cursors are helpful when performing operations that must be processed sequentially rather than in a set-based manner. Types of Cursors (SQL Server): A trigger is a set of SQL statements that automatically execute in response to certain events on a table, such as INSERT, UPDATE, or DELETE. Triggers help maintain data consistency, enforce business rules, and implement complex integrity constraints. The SELECT statement retrieves data from one or more tables. It is the most commonly used command in SQL, allowing users to filter, sort, and display data based on specific criteria. NULL represents a missing or unknown value. It is different from zero or an empty string. NULL values indicate that the data is not available or applicable. A stored procedure is a precompiled set of SQL statements stored in the database. It can take input parameters, perform logic and queries, and return output values or result sets. Stored procedures improve performance and maintainability by centralizing business logic. 1. DDL (Data Definition Language): These commands are used to define and modify the structure of database objects such as tables, indexes, and views. For example, the CREATE command creates a new table, the ALTER command modifies an existing table, and the DROP command removes a table entirely. DDL commands primarily focus on the schema or structure of the database. Example: 2. DML (Data Manipulation Language): These commands deal with the actual data stored within database objects. For instance, the INSERT command adds rows of data to a table, the UPDATE command modifies existing data, and the DELETE command removes rows from a table. In short, DML commands allow you to query and manipulate the data itself rather than the structure. Example: The ALTER command is used to modify the structure of an existing database object. This command is essential for adapting our database schema as requirements evolve. A composite primary key is a primary key made up of two or more columns. Together, these columns must form a unique combination for each row in the table. It’s used when a single column isn’t sufficient to uniquely identify a record. Example: Consider an Orders table where OrderID and ProductID together uniquely identify each record because multiple orders might include the same product, but not within the same order. CREATE TABLE OrderDetails ( OrderID INT, ProductID INT, Quantity INT, PRIMARY KEY (OrderID, ProductID) ); Data integrity refers to the accuracy, consistency, and reliability of the data stored in the database. SQL databases maintain data integrity through several mechanisms: The UNION operator combines the result sets of two or more SELECT queries into a single result set, removing duplicate rows. The result sets must have the same number of columns and compatible data types for corresponding columns. Example: SELECT Name FROM Customers UNION SELECT Name FROM Employees; Use UNION when you need only unique records, and UNION ALL when performance matters and duplicates are acceptable. Example: SELECT Name FROM Customers UNION ALL SELECT Name FROM Employees; The CASE statement is SQL’s way of implementing conditional logic in queries. It evaluates conditions and returns a value based on the first condition that evaluates to true. If no condition is met, it can return a default value using the ELSE clause. Example: SELECT ID, CASE WHEN Salary > 100000 THEN 'High' WHEN Salary BETWEEN 50000 AND 100000 THEN 'Medium' ELSE 'Low' END AS SalaryLevel FROM Employees; Scalar functions operate on individual values and return a single value as a result. They are often used for formatting or converting data. Common examples include: Example: SELECT LEN('Example') AS StringLength; The COALESCE function returns the first non-NULL value from a list of expressions. It’s commonly used to provide default values or handle missing data gracefully. Example: SELECT COALESCE(NULL, NULL, 'Default Value') AS Result; 1. COUNT(): Counts the number of rows or non-NULL values in a column. Example: SELECT COUNT(*) FROM Orders; 2. SUM(): Adds up all numeric values in a column. Example: SELECT SUM(TotalAmount) FROM Orders; Example: SELECT NVL(Salary, 0) AS AdjustedSalary FROM Employees;  -- Replaces NULL with 0 SELECT NVL2(Salary, Salary, 0) AS AdjustedSalary FROM Employees;  -- If Salary is NULL, returns 0; otherwise, returns Salary. Example: SELECT Name, Salary, RANK() OVER (ORDER BY Salary DESC) AS Rank FROM Employees; If two employees have the same salary, they get the same rank, but RANK() will skip a number for the next rank, while DENSE_RANK() will not. Example: SELECT Name, ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RowNum FROM Employees; A CTE is a temporary result set defined within a query. It improves query readability and can be referenced multiple times. Example: WITH TopSalaries AS ( SELECT Name, Salary FROM Employees WHERE Salary > 50000 ) SELECT * FROM TopSalaries WHERE Name LIKE 'A%'; Window functions allow you to perform calculations across a set of table rows that are related to the current row within a result set, without collapsing the result set into a single row. These functions can be used to compute running totals, moving averages, rank rows, etc. SELECT Name, Salary, SUM(Salary) OVER (ORDER BY Salary) AS RunningTotal FROM Employees; 1. Index 2. Key Indexing allows the database to locate and access the rows corresponding to a query condition much faster than scanning the entire table. Instead of reading each row sequentially, the database uses the index to jump directly to the relevant data pages. This reduces the number of disk I/O operations and speeds up query execution, especially for large tables. Example: CREATE INDEX idx_lastname ON Employees(LastName); SELECT * FROM Employees WHERE LastName = 'Smith'; The index on LastName lets the database quickly find all rows matching ‘Smith’ without scanning every record. Advantages Disadvantages: 1. Clustered Index: 2. Non-Clustered Index: Temporary tables are tables that exist only for the duration of a session or a transaction. They are useful for storing intermediate results, simplifying complex queries, or performing operations on subsets of data without modifying the main tables. 1. Local Temporary Tables: 2. Global Temporary Tables: Example: CREATE TABLE #TempResults (ID INT, Value VARCHAR(50)); INSERT INTO #TempResults VALUES (1, 'Test'); SELECT * FROM #TempResults; Standard View: Materialized View: In Oracle/Postgres , you use: REFRESH MATERIALIZED VIEW my_view; A sequence is a database object that generates a series of unique numeric values. It’s often used to produce unique identifiers for primary keys or other columns requiring sequential values. Example: CREATE SEQUENCE seq_emp_id START WITH 1 INCREMENT BY 1; SELECT NEXT VALUE FOR seq_emp_id; -- Returns 1 SELECT NEXT VALUE FOR seq_emp_id; -- Returns 2 1. Greater Flexibility: 2. Dynamic Adjustment: Can alter the sequence without modifying the table structure. 3. Cross-Table Consistency: Use a single sequence for multiple related tables to ensure unique identifiers across them. In short, sequences offer more control and reusability than identity columns. Constraints enforce rules that the data must follow, preventing invalid or inconsistent data from being entered: Local Temporary Table: Global Temporary Table: Example: CREATE TABLE #LocalTemp (ID INT); CREATE TABLE ##GlobalTemp (ID INT); The MERGE statement combines multiple operations INSERT, UPDATE, and DELETE into one. It is used to synchronize two tables by: Example: MERGE INTO TargetTable T USING SourceTable S ON T.ID = S.ID WHEN MATCHED THEN UPDATE SET T.Value = S.Value WHEN NOT MATCHED THEN INSERT (ID, Value) VALUES (S.ID, S.Value); 1. GROUP BY: Aggregate rows to eliminate duplicates SELECT Column1, MAX(Column2) FROM TableName GROUP BY Column1; 2. ROW_NUMBER(): Assign a unique number to each row and filter by that WITH CTE AS ( SELECT Column1, Column2, ROW_NUMBER() OVER (PARTITION BY Column1 ORDER BY Column2) AS RowNum FROM TableName ) SELECT * FROM CTE WHERE RowNum = 1; A correlated subquery is a subquery that references columns from the outer query. It is re-executed for each row processed by the outer query. This makes it more dynamic, but potentially less efficient. Example: SELECT Name, (SELECT COUNT(*) FROM Orders WHERE Orders.CustomerID = Customers.CustomerID) AS OrderCount FROM Customers; Partitioned tables divide data into smaller, more manageable segments based on a column’s value (e.g., date or region). Each partition is stored separately, making queries that target a specific partition more efficient. It is used when ACID is an acronym that stands for Atomicity, Consistency, Isolation, and Durability, four key properties that ensure database transactions are processed reliably. 1. Atomicity: 2. Consistency: 3. Isolation: 4. Durability: Isolation levels define the extent to which the operations in one transaction are isolated from those in other transactions. They are critical for managing concurrency and ensuring data integrity. Common isolation levels include: 1. Read Uncommitted: 2. Read Committed: 3. Repeatable Read: 4. Serializable: Example: SELECT * FROM Orders WITH (NOLOCK); This query fetches data from the Orders table without waiting for other transactions to release their locks. Deadlocks occur when two or more transactions hold resources that the other transactions need, resulting in a cycle of dependency that prevents progress. Strategies to handle deadlocks include: 1. Deadlock detection and retry: 2. Reducing lock contention: 3. Using proper isolation levels: 4. Consistent ordering of resource access: A database snapshot is a read-only, static view of a database at a specific point in time. Example: CREATE DATABASE MySnapshot ON ( NAME = MyDatabase_Data, FILENAME = 'C:\Snapshots\MyDatabase_Snapshot.ss' ) AS SNAPSHOT OF MyDatabase; 1. OLTP (Online Transaction Processing) 2. OLAP (Online Analytical Processing) 1. Live Lock 2. Deadlock The EXCEPT operator is used to return rows from one query’s result set that are not present in another query’s result set. It effectively performs a set difference, showing only the data that is unique to the first query. Example: SELECT ProductID FROM ProductsSold EXCEPT SELECT ProductID FROM ProductsReturned; Use Case: Performance Considerations: Dynamic SQL is SQL code that is constructed and executed at runtime rather than being fully defined and static. In SQL Server: Use sp_executesql or EXEC. In other databases: Concatenate query strings and execute them using the respective command for the database platform. Syntax: DECLARE @sql NVARCHAR(MAX) SET @sql = 'SELECT * FROM ' + @TableName EXEC sp_executesql @sql; Advantages: Risks: Partitioning is a database technique used to divide data into smaller, more manageable pieces. Horizontal Partitioning: Vertical Partitioning: Key Difference: 1. Indexing Strategy: 2. Index Types: 3. Partitioned Indexes: 4. Maintenance Overhead: 5. Monitoring and Tuning: Indexing large tables requires a careful approach to ensure that performance gains from faster queries outweigh the costs of increased storage and maintenance effort. 1. Sharding 2. Partitioning 1. Write Simple, Clear Queries: 2. Filter Data Early: 3. ** Avoid SELECT * : 4. Use Indexes Wisely: 5. Leverage Query Execution Plans: 6. Use Appropriate Join Types: 7. Break Down Complex Queries: 8. Optimize Aggregations: 9.  Monitor Performance Regularly: 1. Use Execution Plans: Review the execution plan of queries to understand how the database is retrieving data, which indexes are being used, and where potential bottlenecks exist. 2. Analyze Wait Statistics: Identify where queries are waiting, such as on locks, I/O, or CPU, to pinpoint the cause of slowdowns. 3. Leverage Built-in Monitoring Tools: 4. Set Up Alerts and Baselines: 5. Continuous Query Tuning: 1. Indexing 2. Denormalization SQL handles recursive queries using Common Table Expressions (CTEs). A recursive CTE repeatedly references itself to process hierarchical or tree-structured data. Key Components: Example: WITH RecursiveCTE (ID, ParentID, Depth) AS ( SELECT ID, ParentID, 1 AS Depth FROM Categories WHERE ParentID IS NULL UNION ALL SELECT c.ID, c.ParentID, r.Depth + 1 FROM Categories c INNER JOIN RecursiveCTE r ON c.ParentID = r.ID ) SELECT * FROM RecursiveCTE; 1. Transactional Queries: 2. Analytical Queries: 3. Key Differences: 1. Use Distributed Transactions: Implement two-phase commit (2PC) to ensure all participating databases commit changes simultaneously or roll back if any part fails. 2. Implement Eventual Consistency: If strong consistency isn’t required, allow data to become consistent over time. This approach is common in distributed systems where high availability is a priority. 3. Conflict Resolution Mechanisms: Use versioning, timestamps, or conflict detection rules to resolve inconsistencies. 4. Data Replication and Synchronization: Use reliable replication strategies to ensure that changes made in one database are propagated to others. 5. Regular Audits and Validation: Periodically verify that data remains consistent across databases and fix discrepancies as needed. The PIVOT operator transforms rows into columns, making it easier to summarize or rearrange data for reporting. Example: Converting a dataset that lists monthly sales into a format that displays each month as a separate column. SELECT ProductID, [2021], [2022] FROM ( SELECT ProductID, YEAR(SaleDate) AS SaleYear, Amount FROM Sales ) AS Source PIVOT ( SUM(Amount) FOR SaleYear IN ([2021], [2022]) ) AS PivotTable; 1. Bitmap Index: 2. B-tree Index: 3. Key Difference: This section is dedicated to questions that focus on writing and understanding SQL queries. By practicing these examples, we’ll learn how to retrieve, manipulate, and analyze data effectively, building the problem-solving skills needed for real-world scenarios. SELECT MAX(Salary) AS SecondHighestSalary FROM Employee WHERE Salary < (SELECT MAX(Salary) FROM Employee); Explanation: This query identifies the second-highest salary by selecting the maximum salary that is less than the overall highest salary. The subquery determines the top salary, while the outer query finds the next highest value. SELECT * FROM Employee e WHERE e.Salary > (SELECT AVG(Salary) FROM Employee); Explanation: This query fetches details of employees whose salary exceeds the average salary. The subquery calculates the average salary, and the main query filters rows based on that result. SELECT ColumnName, COUNT(*) FROM TableName GROUP BY ColumnName HAVING COUNT(*) > 1; Explanation: The query uses GROUP BY to group identical values and HAVING COUNT(*) > 1 to identify values that appear more than once in the specified column. SELECT * FROM Employee WHERE JoiningDate > DATE_SUB(CURDATE(), INTERVAL 30 DAY); Explanation: By comparing the JoiningDate to the current date minus 30 days, this query retrieves all employees who joined within the last month. SELECT * FROM Employee ORDER BY Salary DESC LIMIT 3; Explanation: The query sorts employees by salary in descending order and uses LIMIT 3 to return only the top three earners. DELETE e FROM Employee e JOIN ( SELECT MIN(EmployeeID) AS keep_id, Column1, Column2 FROM Employee GROUP BY Column1, Column2 ) k ON e.Column1 = k.Column1 AND e.Column2 = k.Column2 WHERE e.EmployeeID <> k.keep_id; Explanation : This query retains only one row for each set of duplicates by keeping the row with the smallest EmployeeID. It identifies duplicates using GROUP BY and removes rows not matching the minimum ID. SELECT * FROM TableA INNER JOIN TableB ON TableA.ID = TableB.ID; Explanation: An INNER JOIN is used to find rows present in both tables by matching a common column (in this case, ID). SELECT * FROM Employee WHERE Name LIKE 'A%' AND Name LIKE '%A'; Explanation: The query uses LIKE with wildcard characters to filter rows where the Name column starts and ends with the letter 'A'. SELECT DepartmentID, COUNT(*) AS EmployeeCount FROM Employee GROUP BY DepartmentID; Explanation: By grouping employees by their DepartmentID and counting rows in each group, the query produces a list of departments along with the employee count. SELECT * FROM Employee WHERE ManagerID IS NULL; Explanation: This query selects employees whose ManagerID column is NULL, indicating they don’t report to a manager. WITH SalaryRank AS ( SELECT Salary, RANK() OVER (ORDER BY Salary DESC) AS Rank FROM Employee ) SELECT Salary FROM SalaryRank WHERE Rank IN (3, 4); Explanation: This query uses the RANK() window function to rank the salaries in descending order. The outer query then selects the 3rd and 4th highest salaries by filtering for those ranks. SELECT MAX(CASE WHEN ColumnName = 'Condition1' THEN Value END) AS Column1, MAX(CASE WHEN ColumnName = 'Condition2' THEN Value END) AS Column2 FROM TableName; Explanation: This query converts specific row values into columns using conditional aggregation with CASE. Each column’s value is determined based on a condition applied to rows. SELECT * FROM TableName WHERE UpdatedAt >= NOW() - INTERVAL 1 HOUR; Explanation : By comparing the UpdatedAt timestamp to the current time minus one hour, the query retrieves rows updated in the last 60 minutes. SELECT * FROM Employee WHERE DepartmentID IN ( SELECT DepartmentID FROM Employee GROUP BY DepartmentID HAVING COUNT(*) < 5 ); Explanation : The subquery counts employees in each department, and the main query uses those results to find employees working in departments with fewer than 5 members. SELECT CASE WHEN EXISTS (SELECT * FROM TableName) THEN 'Has Records' ELSE 'No Records' END AS Status; Explanation : The query uses EXISTS to determine if any rows exist in the table, returning a status of 'Has Records' or 'No Records' based on the result. SELECT e.EmployeeID, e.Salary FROM Employee e JOIN Employee m ON e.ManagerID = m.EmployeeID WHERE e.Salary > m.Salary; Explanation : This query joins the Employee table with itself to compare employee salaries to their respective managers’ salaries, selecting those who earn more. WITH RowNumbered AS ( SELECT *, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS RowNum FROM Employee ) SELECT * FROM RowNumbered WHERE RowNum % 2 = 0; Explanation : This query assigns a sequential number to each row using ROW_NUMBER(), then selects rows where the row number is even, effectively fetching alternating rows. The ORDER BY (SELECT NULL) is used to avoid any specific ordering and just apply a sequential numbering. SELECT DepartmentID FROM Employee GROUP BY DepartmentID ORDER BY AVG(Salary) DESC LIMIT 1; Explanation: Grouping by DepartmentID and ordering by the average salary in descending order, the query returns the department with the highest average. WITH OrderedEmployees AS ( SELECT *, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS RowNum FROM Employee ) SELECT * FROM OrderedEmployees WHERE RowNum = n; Explanation : This query uses ROW_NUMBER() to generate a sequential number for each row. The outer query then retrieves the row where the number matches the desired nth position. The approach is portable across most databases. SELECT * FROM Employee WHERE MONTH(JoiningDate) = MONTH(CURDATE()); Explanation: By comparing the month of JoiningDate to the current month, the query selects all employees who were hired in that month regardless of the year. Read more about SQL Query Interview Questions
======================================================================

Link text: C Programming Language Tutorial - GeeksforGeeks
URL: https://www.geeksforgeeks.org/c-programming-language/
Article headline: C Programming Tutorial
Last updated: 22 Sep, 2025
Description: C is a general-purpose mid-level programming language developed by Dennis M. Ritchie at Bell Laboratories in 1972. It was initially used for the development of UNIX operating system, but it later became popular for a wide range of applications. Today, C remains one of the top three most widely used programming languages. This section of the C Tutorial includes basic concepts that build the foundation for writing C programs. It teaches you how to store and output data, perform arithmetic and other operations, control the program flow, etc. Functions are block of code that performs a specific task. They allow programmers to write modular and reusable code. Compound data types are created from primitive data types and provides a different way to use them according to our needs. This section of C tutorial teaches you about the compound data types and how to efficiently organize and process real world data. This section covers the manual memory management in C using pointers. The dynamic memory management in C uses functions like malloc(), calloc(), realloc(), and free() to manually manage the memory while avoiding errors such as memory leak. This section teaches you how to work with files in C, including creating, reading, writing, manipulating and deleting files. Unlike other programming languages that have automatic error handling, In C language error handling is to be manually done by the developers using error-handling methods, debugging strategies, and functions like perror(), strerror(), etc. This section explores various essential of C language that do not fit into a single category but play a vital role in C programming and provide advanced functionality to your program. This section teaches you high-level C programming techniques such as multi-threading, signal handling, socket programming, etc which are used in creating high-performance robust applications and systems. Now that you have a strong foundation in C language, you can explore more advanced topics such as Data structures and Algorithms in C. Keep challenging yourself with our collection of practice problems to further strengthen you understanding of the language:
======================================================================

Link text: Types of Network Topology - GeeksforGeeks
URL: https://www.geeksforgeeks.org/types-of-network-topology/
Article headline: Types of Network Topology
Last updated: 18 Sep, 2025
Description: A network topology is the arrangement of devices (nodes) and connections (links) in a computer network. It shows how computers, servers, and other devices are connected and how data flows between them. There are two main types of topology: Note: Choosing the right topology is important because it affects the performance, cost, reliability, and security of the network. Point-to-point topology is a type of topology that works on the functionality of the sender and receiver. It is the simplest communication between two nodes, in which one is the sender and the other one is the receiver. Point-to-Point provides high bandwidth. In a mesh topology, every device is connected to another device via a particular channel. Every device is connected to another via dedicated channels. These channels are known as links. In Mesh Topology, the protocols used are AHCP (Ad Hoc Configuration Protocols), DHCP (Dynamic Host Configuration Protocol), etc. Note: A common example of mesh topology is the internet backbone, where various internet service providers are connected to each other via dedicated channels. This topology is also used in military communication systems and aircraft navigation systems. In Star Topology, all the devices are connected to a single hub through a cable. This hub is the central node and all other nodes are connected to the central node. The hub can be passive in nature i.e., not an intelligent hub such as broadcasting devices, at the same time the hub can be intelligent known as an active hub. Active hubs have repeaters in them. Note: Here, Coaxial cables or RJ-45 cables are used to connect the computers & many popular Ethernet LAN protocols are used as CD(Collision Detection), CSMA (Carrier Sense Multiple Access), etc. Note: A common example of star topology is a local area network (LAN) in an office where all computers are connected to a central hub. This topology is also used in wireless networks where all devices are connected to a wireless access point. Bus Topology is a network type in which every computer and network device is connected to a single cable. It is bi-directional. It is a multi-point connection and a non-robust topology because if the backbone fails the topology crashes. In Bus Topology, various MAC (Media Access Control) protocols are followed by LAN ethernet connections like TDMA , Pure Aloha , CDMA, Slotted Aloha , etc. Note: A common example of bus topology is the Ethernet LAN, where all devices are connected to a single coaxial cable or twisted pair cable. This topology is also used in cable television networks. In a Ring Topology, it forms a ring connecting devices with exactly two neighboring devices. A number of repeaters are used for Ring topology with a large number of nodes, because if someone wants to send some data to the last node in the ring topology with 100 nodes, then the data will have to pass through 99 nodes to reach the 100th node. Hence to prevent data loss repeaters are used in the network. In-Ring Topology, the Token Ring Passing protocol is used by the workstations to transmit the data where, Token passing is a network access method in which a token is passed from one node to another node & Token is a frame that circulates around the network. Note: Here, data flows in one direction, but it can be made bidirectional by having 2 connections between each Network Node, it is called Dual Ring Topology. Tree topology is the variation of the Star topology. This topology has a hierarchical flow of data. In Tree Topology, protocols like DHCP and SAC (Standard Automatic Configuration) are used. Note: A common example of a tree topology is the hierarchy in a large organization. CEO is the root, who is connected to the different departments(child nodes) of the company, managers overseeing different teams (grandchild nodes) & team members (leaf nodes) are at the bottom of the hierarchy. Hybrid Topology is the combination of all the various types of topologies we have studied above. Hybrid Topology is used when the nodes are free to take any form. It means these can be individuals such as Ring or Star topology or can be a combination of various types of topologies seen above. Each individual topology uses the protocol that has been discussed earlier. Note: A common example of a hybrid topology is a university campus network. The network may have a backbone of a star topology, with each building connected to the backbone through a switch or router. Within each building, there may be a bus or ring topology connecting the different rooms and offices. Network Topology is important because it defines how devices are connected and how they communicate in the network. Here are some points that defines why network topology is important.
======================================================================

Link text: Top 50+ Python Interview Questions and Answers (2025)
URL: https://www.geeksforgeeks.org/python-interview-questions/
Article headline: Python Interview Questions and Answers (2025)
Last updated: 04 Oct, 2025
Description: Python is a high-level, interpreted programming language known for its simplicity, readability, and extensive ecosystem. Created by Guido van Rossum in 1991, Python has become the go-to language for web development, data science, machine learning, automation, scripting, and system programming. Interviewers test candidates on Python fundamentals, object-oriented principles, error handling, built-in data structures, functional programming, and modern features like comprehensions and decorators. This guide is designed to help you prepare comprehensively for Python interviews. This section is foundational for any Python interview and checks your understanding of the language’s syntax, control flow, and basic programming constructs. Common Interview Questions Python’s built-in data structures are powerful and flexible. Mastering them is essential for solving algorithmic problems efficiently. Common Interview Questions OOP enables modular, reusable, and scalable code. Python supports full-fledged OOP features. Common Interview Questions These features make Python concise and expressive. Common Interview Questions For experienced roles, interviewers often dive into more intricate Python concepts. Common Interview Questions Python interviews assess both foundational knowledge and practical coding ability. To prepare effectively:
======================================================================

Link text: Dynamic Programming or DP - GeeksforGeeks
URL: https://www.geeksforgeeks.org/dynamic-programming/
Article headline: Dynamic Programming or DP
Last updated: 25 Jul, 2025
Description: Dynamic Programming is an algorithmic technique with the following properties.  Quick Links:
======================================================================

Link text: Decorators in Python - GeeksforGeeks
URL: https://www.geeksforgeeks.org/decorators-in-python/
Article headline: Decorators in Python
Last updated: 22 Sep, 2025
Description: In Python, decorators are flexible way to modify or extend behavior of functions or methods, without changing their actual code. Example: Let's see an example in which a simple Python decorator adds behavior before and after a function call. Explanation: Decorators often need to work with functions that have arguments. We use *args and **kwargs so our wrapper can accept any number of arguments. Example: Let's see an example of a decorator that adds functionality before and after a function call. In Python, functions are first-class objects , meaning they can be treated like any other object (such as integers, strings or lists). This allows functions to be assigned to variables , passed as arguments , returned from other functions and stored in data structures enabling flexible programming patterns, including decorators. Example: This code demonstrates all four properties of functions as first-class objects in Python. Explanation: Higher-order functions are functions that take one or more functions as arguments, return a function as a result or do both. Essentially, a higher-order function is a function that operates on other functions. This is a powerful concept in functional programming and is a key component in understanding how decorators work. Example: This code shows a higher-order function that takes another function as an argument and applies it to a given value. Explanation: fun is a higher-order function because it takes another function f as an argument and applies it to the value x . Decorators are higher-order functions that take a function, modify it and return a new one with extended or altered behavior. The most common decorators in Python, used to wrap and enhance functions by adding extra behavior before or after the original function runs. Example: In this Example, a decorator prints a message before and after executing wrapped function. Explanation: Special decorators used for methods inside a class. They work like function decorators but handle the self parameter for instance methods. Example: Here, a decorator prints a message before and after a method is executed, while correctly handling self argument. Explanation: Class decorators are used to modify or enhance behavior of a class. Like function decorators, class decorators are applied to class definition. They work by taking class as an argument and returning a modified version of class. Example: This code demonstrates a class decorator that adds a class_name attribute to a class, storing class’s name. Explanation: Python provides several built-in decorators that are used in class definitions. These decorators modify behavior of methods and attributes in a class, making it easier to manage and use them effectively. The most frequently used built-in decorators are @staticmethod , @classmethod and @property . It is used to define a method that doesn't operate on an instance of class (i.e., it doesn't use self). Static methods are called on class itself, not on an instance of class. Example: This example shows how to define and use a @staticmethod inside a class. Explanation: It is used to define a method that operates on class itself (i.e., it uses cls). Class methods can access and modify class state that applies across all instances of class. Example: This code defines a class Employee with a class variable raise_amount and a class method set_raise_amount that updates this variable for entire class. Explanation: It is used to define a method as a property, which allows you to access it like an attribute. This is useful for encapsulating implementation of a method while still providing a simple interface. Example: This code defines a circle class demonstrating @property for controlled attribute access, allowing safe updates to radius. Explanation: Chaining decorators means applying multiple decorators to same function. Each decorator wraps function in sequence, adding layered behavior. Example: This example shows how chaining decorators works by applying two decorators in different orders to see how output changes. Explanation:
======================================================================

Link text: Maximum Subarray Sum - Kadane's Algorithm - GeeksforGeeks
URL: https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/
Article headline: Maximum Subarray Sum  - Kadane's Algorithm
Last updated: 22 Jul, 2025
Description: Given an integer array arr[] , find the subarray (containing at least one element) which has the maximum possible sum , and return that sum. Note: A subarray is a continuous part of an array. Examples: Input: arr[] = [2, 3, -8, 7, -1, 2, 3] Output: 11 Explanation: The subarray [7, -1, 2, 3] has the largest sum 11. Input: arr[] = [-2, -4] Output: -2 Explanation: The subarray [-2] has the largest sum -2. Input: arr[] = [5, 4, 1, 7, 8] Output: 25 Explanation: The subarray [5, 4, 1, 7, 8] has the largest sum 25. The idea is to run two nested loops to iterate over all possible subarrays and find the maximum sum. The outer loop will mark the starting point of a subarray and inner loop will mark the ending point of the subarray. The idea of Kadane's algorithm is to traverse over the array from left to right and for each element, find the maximum sum among all subarrays ending at that element . The result will be the maximum of all these values. To calculate the maximum sum of subarray ending at current element, say maxEnding , we can use the maximum sum ending at the previous element. So for any element, we have two choices: Choice 1: Extend the maximum sum subarray ending at the previous element by adding the current element to it. If the maximum subarray sum ending at the previous index is positive , then it is always better to extend the subarray. Choice 2: Start a new subarray starting from the current element. If the maximum subarray sum ending at the previous index is negative , it is always better to start a new subarray from the current element. This means that maxEnding at index i = max(maxEnding at index (i - 1) + arr[i], arr[i]) and the maximum value of maxEnding at any index will be our answer. Illustration: Related Articles:
======================================================================

Link text: SQL | WITH Clause - GeeksforGeeks
URL: https://www.geeksforgeeks.org/sql-with-clause/
Article headline: SQL WITH Clause
Last updated: 13 Sep, 2025
Description: The SQL WITH clause is used to define temporary tables or result sets within a query: Note: When a query with a WITH clauseis executed, first the query mentioned within the  clause is evaluated and the output of this evaluation is stored in a temporary relation. Following this, the main query associated with the WITH clause is finally executed that would use the temporary relation produced. Let's look at some practical examples of WITH Clause in SQLto better understand how it can simplify complex queries and improve query performance: This example demonstrates how to find all employees whose salary is higher than the average salary of all employees in the database . The query calculates the average salary using the WITH clause and compares each employee's salary against this average to return those with above-average salaries. EmployeeTable Query: Output Explanation: In this example, we aim to find airlines where the total salary of all pilots exceeds the average salary of all pilots in the database. The WITH clause will be used to first calculate the total salary for each airline and then compare it to the overall average salary. Pilot Table Query: Output Explanation: The total salary of all pilots of Airbus 380 = 298,830 and that of Boeing = 45000. Average salary of all pilots in the table Pilot = 57305. Since only the total salary of all pilots of Airbus 380 is greater than the average salary obtained, so Airbus 380 lies in the output relation. 1. Improved Readability : The WITH clause breaks down complex queries into simpler parts, making it easier to follow the logic. 2. Reusable Subqueries : If you need to reference the same subquery multiple times in your query, the WITH clause saves you from repeating the same code. 3. Performance Optimization : By storing intermediate results, SQL databases can optimize the execution of queries, potentially improving performance. 4. Easy Debugging : Since each CTE is defined separately, it's easier to test and debug different parts of the query without affecting the main logic. 1. Temporary Lifetime : The temporary tables (CTEs) defined in the WITH clause only exist during the execution of the query. Once the query is finished, they are discarded. 2. Nested WITH Clauses : You can define multiple CTEs in a single query, and they can reference each other. Example: 3. Performance Consideration : While the WITH clause is excellent for readability and maintainability, it can sometimes be less efficient in cases where the temporary result set is large. Always check the execution plan to ensure you're optimizing your queries correctly.
======================================================================

Link text: Stack in Python - GeeksforGeeks
URL: https://www.geeksforgeeks.org/stack-in-python/
Article headline: Stack in Python
Last updated: 13 Sep, 2025
Description: A stack is a linear data structure that follows the Last-In/First-Out (LIFO) principle, also known as First-In/Last-Out (FILO). This means that the last element added is the first one to be removed. In a stack, both insertion and deletion happen at the same end, which is called the top of the stack. Stacks support a small set of basic operations, all of which run in O (1) time: Python does not have a built-in stack type, but stacks can be implemented in different ways using different data structures, let's look at some of the implementations: Example: Lists may slow down when they grow very large due to memory reallocation. Example:
======================================================================

Link text: Vector in C++ STL - GeeksforGeeks
URL: https://www.geeksforgeeks.org/vector-in-cpp-stl/
Article headline: Vector in C++ STL
Last updated: 19 Sep, 2025
Description: A vector represents a dynamic sized array in the Standard Template Library(STL) that automatically grows when elements are added beyond current capacity. A vector is defined as the std::vector class template in the < vector > header file. where T is the data type of elements and v is the name assigned to the vector. Vectors in C++ support various useful operations that allow you to add, remove, access, and modify elements dynamically. We can find the size(number of elements) of a vector using the size() function, like v.size(). Multidimensional vectors are dynamic arrays that can store data in more than one dimension, like tables or grids. They are implemented using vector inside another vector, allowing flexible row-column (2D), or even higher-dimensional structures. We can access elements using two indices:
======================================================================

